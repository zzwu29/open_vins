\hypertarget{classov__eval_1_1ResultTrajectory}{}\section{ov\+\_\+eval\+:\+:Result\+Trajectory类 参考}
\label{classov__eval_1_1ResultTrajectory}\index{ov\+\_\+eval\+::\+Result\+Trajectory@{ov\+\_\+eval\+::\+Result\+Trajectory}}


A single run for a given dataset.  




{\ttfamily \#include $<$Result\+Trajectory.\+h$>$}

\subsection*{Public 成员函数}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classov__eval_1_1ResultTrajectory_a91d8d079db9f290d384746b7a030e336}{Result\+Trajectory} (std\+::string path\+\_\+est, std\+::string path\+\_\+gt, std\+::string alignment\+\_\+method)
\begin{DoxyCompactList}\small\item\em Default constructor that will load, intersect, and align our trajectories. \end{DoxyCompactList}\item 
void \hyperlink{classov__eval_1_1ResultTrajectory_aa82df799f7eb6ccc6f7665cd7a383c40}{calculate\+\_\+ate} (\hyperlink{structov__eval_1_1Statistics}{Statistics} \&error\+\_\+ori, \hyperlink{structov__eval_1_1Statistics}{Statistics} \&error\+\_\+pos)
\begin{DoxyCompactList}\small\item\em Computes the Absolute Trajectory Error (A\+TE) for this trajectory. \end{DoxyCompactList}\item 
void \hyperlink{classov__eval_1_1ResultTrajectory_aea298386d6615b31a75e9578baf77497}{calculate\+\_\+ate\+\_\+2d} (\hyperlink{structov__eval_1_1Statistics}{Statistics} \&error\+\_\+ori, \hyperlink{structov__eval_1_1Statistics}{Statistics} \&error\+\_\+pos)
\begin{DoxyCompactList}\small\item\em Computes the Absolute Trajectory Error (A\+TE) for this trajectory in the 2d x-\/y plane. \end{DoxyCompactList}\item 
void \hyperlink{classov__eval_1_1ResultTrajectory_abf4d8b00abdf68692ceaa85b5c1c5b0f}{calculate\+\_\+rpe} (const std\+::vector$<$ double $>$ \&segment\+\_\+lengths, std\+::map$<$ double, std\+::pair$<$ \hyperlink{structov__eval_1_1Statistics}{Statistics}, \hyperlink{structov__eval_1_1Statistics}{Statistics} $>$$>$ \&error\+\_\+rpe)
\begin{DoxyCompactList}\small\item\em Computes the Relative Pose Error (R\+PE) for this trajectory \end{DoxyCompactList}\item 
void \hyperlink{classov__eval_1_1ResultTrajectory_ad8ed667bd451302f503b2bc761796d9f}{calculate\+\_\+nees} (\hyperlink{structov__eval_1_1Statistics}{Statistics} \&nees\+\_\+ori, \hyperlink{structov__eval_1_1Statistics}{Statistics} \&nees\+\_\+pos)
\begin{DoxyCompactList}\small\item\em Computes the Normalized Estimation Error Squared (N\+E\+ES) for this trajectory. \end{DoxyCompactList}\item 
void \hyperlink{classov__eval_1_1ResultTrajectory_a8c8675c3a9ebc8415e41c38175691e46}{calculate\+\_\+error} (\hyperlink{structov__eval_1_1Statistics}{Statistics} \&posx, \hyperlink{structov__eval_1_1Statistics}{Statistics} \&posy, \hyperlink{structov__eval_1_1Statistics}{Statistics} \&posz, \hyperlink{structov__eval_1_1Statistics}{Statistics} \&orix, \hyperlink{structov__eval_1_1Statistics}{Statistics} \&oriy, \hyperlink{structov__eval_1_1Statistics}{Statistics} \&oriz, \hyperlink{structov__eval_1_1Statistics}{Statistics} \&roll, \hyperlink{structov__eval_1_1Statistics}{Statistics} \&pitch, \hyperlink{structov__eval_1_1Statistics}{Statistics} \&yaw)
\begin{DoxyCompactList}\small\item\em Computes the error at each timestamp for this trajectory. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected 成员函数}
\begin{DoxyCompactItemize}
\item 
std\+::vector$<$ int $>$ \hyperlink{classov__eval_1_1ResultTrajectory_af47fbcba5026b01aeb00df5c835ba296}{compute\+\_\+comparison\+\_\+indices\+\_\+length} (std\+::vector$<$ double $>$ \&distances, double distance, double max\+\_\+dist\+\_\+diff)
\begin{DoxyCompactList}\small\item\em Gets the indices at the end of subtractories of a given length when starting at each index. For each starting pose, find the end pose index which is the desired distance away. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected 属性}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classov__eval_1_1ResultTrajectory_a2e78209342b80d1ac3115bad38ef397c}\label{classov__eval_1_1ResultTrajectory_a2e78209342b80d1ac3115bad38ef397c}} 
std\+::vector$<$ double $>$ {\bfseries est\+\_\+times}
\item 
\mbox{\Hypertarget{classov__eval_1_1ResultTrajectory_a7d985814985338546e06b9a5a49b153e}\label{classov__eval_1_1ResultTrajectory_a7d985814985338546e06b9a5a49b153e}} 
std\+::vector$<$ double $>$ {\bfseries gt\+\_\+times}
\item 
\mbox{\Hypertarget{classov__eval_1_1ResultTrajectory_af603360e09c66c552f08f144aa399b4b}\label{classov__eval_1_1ResultTrajectory_af603360e09c66c552f08f144aa399b4b}} 
std\+::vector$<$ Eigen\+::\+Matrix$<$ double, 7, 1 $>$ $>$ {\bfseries est\+\_\+poses}
\item 
\mbox{\Hypertarget{classov__eval_1_1ResultTrajectory_a27988db61fab2b6154665c5cf5f5eb66}\label{classov__eval_1_1ResultTrajectory_a27988db61fab2b6154665c5cf5f5eb66}} 
std\+::vector$<$ Eigen\+::\+Matrix$<$ double, 7, 1 $>$ $>$ {\bfseries gt\+\_\+poses}
\item 
\mbox{\Hypertarget{classov__eval_1_1ResultTrajectory_a80f44e2b04fafe8114962438abe9164a}\label{classov__eval_1_1ResultTrajectory_a80f44e2b04fafe8114962438abe9164a}} 
std\+::vector$<$ Eigen\+::\+Matrix3d $>$ {\bfseries est\+\_\+covori}
\item 
\mbox{\Hypertarget{classov__eval_1_1ResultTrajectory_a4b3adeb0603f3197484be750db827b39}\label{classov__eval_1_1ResultTrajectory_a4b3adeb0603f3197484be750db827b39}} 
std\+::vector$<$ Eigen\+::\+Matrix3d $>$ {\bfseries est\+\_\+covpos}
\item 
\mbox{\Hypertarget{classov__eval_1_1ResultTrajectory_add4899b2111a01e8e3ea9d29618b0ce4}\label{classov__eval_1_1ResultTrajectory_add4899b2111a01e8e3ea9d29618b0ce4}} 
std\+::vector$<$ Eigen\+::\+Matrix3d $>$ {\bfseries gt\+\_\+covori}
\item 
\mbox{\Hypertarget{classov__eval_1_1ResultTrajectory_a32637a737e1bb09cfe0d6e71fa3d8ccd}\label{classov__eval_1_1ResultTrajectory_a32637a737e1bb09cfe0d6e71fa3d8ccd}} 
std\+::vector$<$ Eigen\+::\+Matrix3d $>$ {\bfseries gt\+\_\+covpos}
\item 
\mbox{\Hypertarget{classov__eval_1_1ResultTrajectory_a9dfef04471027bb002081c55674e41d9}\label{classov__eval_1_1ResultTrajectory_a9dfef04471027bb002081c55674e41d9}} 
std\+::vector$<$ Eigen\+::\+Matrix$<$ double, 7, 1 $>$ $>$ {\bfseries est\+\_\+poses\+\_\+aignedto\+GT}
\item 
\mbox{\Hypertarget{classov__eval_1_1ResultTrajectory_a39957e134124c8f5cc61522df94a03fe}\label{classov__eval_1_1ResultTrajectory_a39957e134124c8f5cc61522df94a03fe}} 
std\+::vector$<$ Eigen\+::\+Matrix$<$ double, 7, 1 $>$ $>$ {\bfseries gt\+\_\+poses\+\_\+aignedto\+E\+ST}
\end{DoxyCompactItemize}


\subsection{详细描述}
A single run for a given dataset. 

This class has all the error function which can be calculated for the loaded trajectory. Given a groundtruth and trajectory we first align the two so that they are in the same frame. From there the following errors could be computed\+:
\begin{DoxyItemize}
\item Absolute trajectory error
\item Relative pose Error
\item Normalized estimation error squared
\item Error and bound at each timestep
\end{DoxyItemize}

Please see the \hyperlink{evaluation}{System Evaluation} page for details and Zhang and Scaramuzza \href{http://rpg.ifi.uzh.ch/docs/IROS18_Zhang.pdf}{\tt A Tutorial on Quantitative Trajectory Evaluation for Visual(-\/\+Inertial) Odometry} paper for implementation specific details. 

\subsection{构造及析构函数说明}
\mbox{\Hypertarget{classov__eval_1_1ResultTrajectory_a91d8d079db9f290d384746b7a030e336}\label{classov__eval_1_1ResultTrajectory_a91d8d079db9f290d384746b7a030e336}} 
\index{ov\+\_\+eval\+::\+Result\+Trajectory@{ov\+\_\+eval\+::\+Result\+Trajectory}!Result\+Trajectory@{Result\+Trajectory}}
\index{Result\+Trajectory@{Result\+Trajectory}!ov\+\_\+eval\+::\+Result\+Trajectory@{ov\+\_\+eval\+::\+Result\+Trajectory}}
\subsubsection{\texorpdfstring{Result\+Trajectory()}{ResultTrajectory()}}
{\footnotesize\ttfamily Result\+Trajectory\+::\+Result\+Trajectory (\begin{DoxyParamCaption}\item[{std\+::string}]{path\+\_\+est,  }\item[{std\+::string}]{path\+\_\+gt,  }\item[{std\+::string}]{alignment\+\_\+method }\end{DoxyParamCaption})}



Default constructor that will load, intersect, and align our trajectories. 


\begin{DoxyParams}{参数}
{\em path\+\_\+est} & Path to the estimate text file \\
\hline
{\em path\+\_\+gt} & Path to the groundtruth text file \\
\hline
{\em alignment\+\_\+method} & The alignment method to use \mbox{[}sim3, se3, posyaw, none\mbox{]} \\
\hline
\end{DoxyParams}


\subsection{成员函数说明}
\mbox{\Hypertarget{classov__eval_1_1ResultTrajectory_aa82df799f7eb6ccc6f7665cd7a383c40}\label{classov__eval_1_1ResultTrajectory_aa82df799f7eb6ccc6f7665cd7a383c40}} 
\index{ov\+\_\+eval\+::\+Result\+Trajectory@{ov\+\_\+eval\+::\+Result\+Trajectory}!calculate\+\_\+ate@{calculate\+\_\+ate}}
\index{calculate\+\_\+ate@{calculate\+\_\+ate}!ov\+\_\+eval\+::\+Result\+Trajectory@{ov\+\_\+eval\+::\+Result\+Trajectory}}
\subsubsection{\texorpdfstring{calculate\+\_\+ate()}{calculate\_ate()}}
{\footnotesize\ttfamily void Result\+Trajectory\+::calculate\+\_\+ate (\begin{DoxyParamCaption}\item[{\hyperlink{structov__eval_1_1Statistics}{Statistics} \&}]{error\+\_\+ori,  }\item[{\hyperlink{structov__eval_1_1Statistics}{Statistics} \&}]{error\+\_\+pos }\end{DoxyParamCaption})}



Computes the Absolute Trajectory Error (A\+TE) for this trajectory. 

This will first do our alignment of the two trajectories. Then at each point the error will be calculated and normed as follows\+: \begin{align*} e_{ATE} &= \sqrt{ \frac{1}{K} \sum_{k=1}^{K} ||\mathbf{x}_{k,i} \boxminus \hat{\mathbf{x}}^+_{k,i}||^2_{2} } \end{align*}


\begin{DoxyParams}{参数}
{\em error\+\_\+ori} & Error values for the orientation \\
\hline
{\em error\+\_\+pos} & Error values for the position \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classov__eval_1_1ResultTrajectory_aea298386d6615b31a75e9578baf77497}\label{classov__eval_1_1ResultTrajectory_aea298386d6615b31a75e9578baf77497}} 
\index{ov\+\_\+eval\+::\+Result\+Trajectory@{ov\+\_\+eval\+::\+Result\+Trajectory}!calculate\+\_\+ate\+\_\+2d@{calculate\+\_\+ate\+\_\+2d}}
\index{calculate\+\_\+ate\+\_\+2d@{calculate\+\_\+ate\+\_\+2d}!ov\+\_\+eval\+::\+Result\+Trajectory@{ov\+\_\+eval\+::\+Result\+Trajectory}}
\subsubsection{\texorpdfstring{calculate\+\_\+ate\+\_\+2d()}{calculate\_ate\_2d()}}
{\footnotesize\ttfamily void Result\+Trajectory\+::calculate\+\_\+ate\+\_\+2d (\begin{DoxyParamCaption}\item[{\hyperlink{structov__eval_1_1Statistics}{Statistics} \&}]{error\+\_\+ori,  }\item[{\hyperlink{structov__eval_1_1Statistics}{Statistics} \&}]{error\+\_\+pos }\end{DoxyParamCaption})}



Computes the Absolute Trajectory Error (A\+TE) for this trajectory in the 2d x-\/y plane. 

This will first do our alignment of the two trajectories. We just grab the yaw component of the orientation and the xy plane error. Then at each point the error will be calculated and normed as follows\+: \begin{align*} e_{ATE} &= \sqrt{ \frac{1}{K} \sum_{k=1}^{K} ||\mathbf{x}_{k,i} \boxminus \hat{\mathbf{x}}^+_{k,i}||^2_{2} } \end{align*}


\begin{DoxyParams}{参数}
{\em error\+\_\+ori} & Error values for the orientation (yaw error) \\
\hline
{\em error\+\_\+pos} & Error values for the position (xy error) \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classov__eval_1_1ResultTrajectory_a8c8675c3a9ebc8415e41c38175691e46}\label{classov__eval_1_1ResultTrajectory_a8c8675c3a9ebc8415e41c38175691e46}} 
\index{ov\+\_\+eval\+::\+Result\+Trajectory@{ov\+\_\+eval\+::\+Result\+Trajectory}!calculate\+\_\+error@{calculate\+\_\+error}}
\index{calculate\+\_\+error@{calculate\+\_\+error}!ov\+\_\+eval\+::\+Result\+Trajectory@{ov\+\_\+eval\+::\+Result\+Trajectory}}
\subsubsection{\texorpdfstring{calculate\+\_\+error()}{calculate\_error()}}
{\footnotesize\ttfamily void Result\+Trajectory\+::calculate\+\_\+error (\begin{DoxyParamCaption}\item[{\hyperlink{structov__eval_1_1Statistics}{Statistics} \&}]{posx,  }\item[{\hyperlink{structov__eval_1_1Statistics}{Statistics} \&}]{posy,  }\item[{\hyperlink{structov__eval_1_1Statistics}{Statistics} \&}]{posz,  }\item[{\hyperlink{structov__eval_1_1Statistics}{Statistics} \&}]{orix,  }\item[{\hyperlink{structov__eval_1_1Statistics}{Statistics} \&}]{oriy,  }\item[{\hyperlink{structov__eval_1_1Statistics}{Statistics} \&}]{oriz,  }\item[{\hyperlink{structov__eval_1_1Statistics}{Statistics} \&}]{roll,  }\item[{\hyperlink{structov__eval_1_1Statistics}{Statistics} \&}]{pitch,  }\item[{\hyperlink{structov__eval_1_1Statistics}{Statistics} \&}]{yaw }\end{DoxyParamCaption})}



Computes the error at each timestamp for this trajectory. 

As compared to A\+TE error (see \hyperlink{classov__eval_1_1ResultTrajectory_aa82df799f7eb6ccc6f7665cd7a383c40}{calculate\+\_\+ate()}) this will compute the error for each individual pose component. This is normally used if you just want to look at a single run on a single dataset. \begin{align*} e_{rmse,k} &= \sqrt{ \frac{1}{N} \sum_{i=1}^{N} ||\mathbf{x}_{k,i} \boxminus \hat{\mathbf{x}}_{k,i}||^2_{2} } \end{align*}


\begin{DoxyParams}{参数}
{\em posx} & Position x-\/axis error and bound if we have it in our file \\
\hline
{\em posy} & Position y-\/axis error and bound if we have it in our file \\
\hline
{\em posz} & Position z-\/axis error and bound if we have it in our file \\
\hline
{\em orix} & Orientation x-\/axis error and bound if we have it in our file \\
\hline
{\em oriy} & Orientation y-\/axis error and bound if we have it in our file \\
\hline
{\em oriz} & Orientation z-\/axis error and bound if we have it in our file \\
\hline
{\em roll} & Orientation roll error and bound if we have it in our file \\
\hline
{\em pitch} & Orientation pitch error and bound if we have it in our file \\
\hline
{\em yaw} & Orientation yaw error and bound if we have it in our file \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classov__eval_1_1ResultTrajectory_ad8ed667bd451302f503b2bc761796d9f}\label{classov__eval_1_1ResultTrajectory_ad8ed667bd451302f503b2bc761796d9f}} 
\index{ov\+\_\+eval\+::\+Result\+Trajectory@{ov\+\_\+eval\+::\+Result\+Trajectory}!calculate\+\_\+nees@{calculate\+\_\+nees}}
\index{calculate\+\_\+nees@{calculate\+\_\+nees}!ov\+\_\+eval\+::\+Result\+Trajectory@{ov\+\_\+eval\+::\+Result\+Trajectory}}
\subsubsection{\texorpdfstring{calculate\+\_\+nees()}{calculate\_nees()}}
{\footnotesize\ttfamily void Result\+Trajectory\+::calculate\+\_\+nees (\begin{DoxyParamCaption}\item[{\hyperlink{structov__eval_1_1Statistics}{Statistics} \&}]{nees\+\_\+ori,  }\item[{\hyperlink{structov__eval_1_1Statistics}{Statistics} \&}]{nees\+\_\+pos }\end{DoxyParamCaption})}



Computes the Normalized Estimation Error Squared (N\+E\+ES) for this trajectory. 

If we have a covariance in addition to our pose estimate we can compute the N\+E\+ES values. At each timestep we compute this for both orientation and position. \begin{align*} e_{nees,k} &= \frac{1}{N} \sum_{i=1}^{N} (\mathbf{x}_{k,i} \boxminus \hat{\mathbf{x}}_{k,i})^\top \mathbf{P}^{-1}_{k,i} (\mathbf{x}_{k,i} \boxminus \hat{\mathbf{x}}_{k,i}) \end{align*}


\begin{DoxyParams}{参数}
{\em nees\+\_\+ori} & N\+E\+ES values for the orientation \\
\hline
{\em nees\+\_\+pos} & N\+E\+ES values for the position \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classov__eval_1_1ResultTrajectory_abf4d8b00abdf68692ceaa85b5c1c5b0f}\label{classov__eval_1_1ResultTrajectory_abf4d8b00abdf68692ceaa85b5c1c5b0f}} 
\index{ov\+\_\+eval\+::\+Result\+Trajectory@{ov\+\_\+eval\+::\+Result\+Trajectory}!calculate\+\_\+rpe@{calculate\+\_\+rpe}}
\index{calculate\+\_\+rpe@{calculate\+\_\+rpe}!ov\+\_\+eval\+::\+Result\+Trajectory@{ov\+\_\+eval\+::\+Result\+Trajectory}}
\subsubsection{\texorpdfstring{calculate\+\_\+rpe()}{calculate\_rpe()}}
{\footnotesize\ttfamily void Result\+Trajectory\+::calculate\+\_\+rpe (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ double $>$ \&}]{segment\+\_\+lengths,  }\item[{std\+::map$<$ double, std\+::pair$<$ \hyperlink{structov__eval_1_1Statistics}{Statistics}, \hyperlink{structov__eval_1_1Statistics}{Statistics} $>$$>$ \&}]{error\+\_\+rpe }\end{DoxyParamCaption})}



Computes the Relative Pose Error (R\+PE) for this trajectory 

For the given set of segment lengths, this will split the trajectory into segments. From there it will compute the relative pose error for all segments. These are then returned as a map for each segment length. \begin{align*} \tilde{\mathbf{x}}_{r} &= \mathbf{x}_{k} \boxminus \mathbf{x}_{k+d_i} \\ e_{rpe,d_i} &= \frac{1}{D_i} \sum_{k=1}^{D_i} ||\tilde{\mathbf{x}}_{r} \boxminus \hat{\tilde{\mathbf{x}}}_{r}||^2_{2} \end{align*}


\begin{DoxyParams}{参数}
{\em segment\+\_\+lengths} & What segment lengths we want to calculate for \\
\hline
{\em error\+\_\+rpe} & Map of segment lengths =$>$ errors for that length (orientation and position) \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classov__eval_1_1ResultTrajectory_af47fbcba5026b01aeb00df5c835ba296}\label{classov__eval_1_1ResultTrajectory_af47fbcba5026b01aeb00df5c835ba296}} 
\index{ov\+\_\+eval\+::\+Result\+Trajectory@{ov\+\_\+eval\+::\+Result\+Trajectory}!compute\+\_\+comparison\+\_\+indices\+\_\+length@{compute\+\_\+comparison\+\_\+indices\+\_\+length}}
\index{compute\+\_\+comparison\+\_\+indices\+\_\+length@{compute\+\_\+comparison\+\_\+indices\+\_\+length}!ov\+\_\+eval\+::\+Result\+Trajectory@{ov\+\_\+eval\+::\+Result\+Trajectory}}
\subsubsection{\texorpdfstring{compute\+\_\+comparison\+\_\+indices\+\_\+length()}{compute\_comparison\_indices\_length()}}
{\footnotesize\ttfamily std\+::vector$<$int$>$ ov\+\_\+eval\+::\+Result\+Trajectory\+::compute\+\_\+comparison\+\_\+indices\+\_\+length (\begin{DoxyParamCaption}\item[{std\+::vector$<$ double $>$ \&}]{distances,  }\item[{double}]{distance,  }\item[{double}]{max\+\_\+dist\+\_\+diff }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}}



Gets the indices at the end of subtractories of a given length when starting at each index. For each starting pose, find the end pose index which is the desired distance away. 


\begin{DoxyParams}{参数}
{\em distances} & Total distance travelled from start at each index \\
\hline
{\em distance} & Distance of subtrajectory \\
\hline
{\em max\+\_\+dist\+\_\+diff} & Maximum error between current trajectory length and the desired \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{返回}
End indices for each subtrajectory 
\end{DoxyReturn}
