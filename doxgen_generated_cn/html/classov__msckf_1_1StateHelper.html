<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenVINS: ov_msckf::StateHelper类 参考</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpenVINS
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'搜索');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','搜索');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceov__msckf.html">ov_msckf</a></li><li class="navelem"><a class="el" href="classov__msckf_1_1StateHelper.html">StateHelper</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">静态 Public 成员函数</a> &#124;
<a href="classov__msckf_1_1StateHelper-members.html">所有成员列表</a>  </div>
  <div class="headertitle">
<div class="title">ov_msckf::StateHelper类 参考</div>  </div>
</div><!--header-->
<div class="contents">

<p>Helper which manipulates the <a class="el" href="classov__msckf_1_1State.html" title="State of our filter ">State</a> and its covariance.  
 <a href="classov__msckf_1_1StateHelper.html#details">更多...</a></p>

<p><code>#include &lt;<a class="el" href="StateHelper_8h_source.html">StateHelper.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
静态 Public 成员函数</h2></td></tr>
<tr class="memitem:a31f92fdf5bac87bfc23d34334af7bd4d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classov__msckf_1_1StateHelper.html#a31f92fdf5bac87bfc23d34334af7bd4d">EKFPropagation</a> (std::shared_ptr&lt; <a class="el" href="classov__msckf_1_1State.html">State</a> &gt; state, const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classov__type_1_1Type.html">ov_type::Type</a> &gt;&gt; &amp;order_NEW, const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classov__type_1_1Type.html">ov_type::Type</a> &gt;&gt; &amp;order_OLD, const Eigen::MatrixXd &amp;Phi, const Eigen::MatrixXd &amp;Q)</td></tr>
<tr class="memdesc:a31f92fdf5bac87bfc23d34334af7bd4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs EKF propagation of the state covariance.  <a href="#a31f92fdf5bac87bfc23d34334af7bd4d">更多...</a><br /></td></tr>
<tr class="separator:a31f92fdf5bac87bfc23d34334af7bd4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a471d81fcc22b706654556950931067fd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classov__msckf_1_1StateHelper.html#a471d81fcc22b706654556950931067fd">EKFUpdate</a> (std::shared_ptr&lt; <a class="el" href="classov__msckf_1_1State.html">State</a> &gt; state, const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classov__type_1_1Type.html">ov_type::Type</a> &gt;&gt; &amp;H_order, const Eigen::MatrixXd &amp;H, const Eigen::VectorXd &amp;res, const Eigen::MatrixXd &amp;R)</td></tr>
<tr class="memdesc:a471d81fcc22b706654556950931067fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs EKF update of the state (see <a class="el" href="update.html#linear-meas">Linear Measurement Update</a> page)  <a href="#a471d81fcc22b706654556950931067fd">更多...</a><br /></td></tr>
<tr class="separator:a471d81fcc22b706654556950931067fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f19646a05e77e67d5be2da8aed19f14"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classov__msckf_1_1StateHelper.html#a5f19646a05e77e67d5be2da8aed19f14">set_initial_covariance</a> (std::shared_ptr&lt; <a class="el" href="classov__msckf_1_1State.html">State</a> &gt; state, const Eigen::MatrixXd &amp;covariance, const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classov__type_1_1Type.html">ov_type::Type</a> &gt;&gt; &amp;order)</td></tr>
<tr class="memdesc:a5f19646a05e77e67d5be2da8aed19f14"><td class="mdescLeft">&#160;</td><td class="mdescRight">This will set the initial covaraince of the specified state elements. Will also ensure that proper cross-covariances are inserted.  <a href="#a5f19646a05e77e67d5be2da8aed19f14">更多...</a><br /></td></tr>
<tr class="separator:a5f19646a05e77e67d5be2da8aed19f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23ec77c8411dcc7cfed64273f6882805"><td class="memItemLeft" align="right" valign="top">static Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classov__msckf_1_1StateHelper.html#a23ec77c8411dcc7cfed64273f6882805">get_marginal_covariance</a> (std::shared_ptr&lt; <a class="el" href="classov__msckf_1_1State.html">State</a> &gt; state, const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classov__type_1_1Type.html">ov_type::Type</a> &gt;&gt; &amp;small_variables)</td></tr>
<tr class="memdesc:a23ec77c8411dcc7cfed64273f6882805"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a given set of variables, this will this will calculate a smaller covariance.  <a href="#a23ec77c8411dcc7cfed64273f6882805">更多...</a><br /></td></tr>
<tr class="separator:a23ec77c8411dcc7cfed64273f6882805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ac98543816e664cd85e4fa61bd165b7"><td class="memItemLeft" align="right" valign="top">static Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classov__msckf_1_1StateHelper.html#a2ac98543816e664cd85e4fa61bd165b7">get_full_covariance</a> (std::shared_ptr&lt; <a class="el" href="classov__msckf_1_1State.html">State</a> &gt; state)</td></tr>
<tr class="memdesc:a2ac98543816e664cd85e4fa61bd165b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This gets the full covariance matrix.  <a href="#a2ac98543816e664cd85e4fa61bd165b7">更多...</a><br /></td></tr>
<tr class="separator:a2ac98543816e664cd85e4fa61bd165b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a6d020115f02fe783ced90b90c32287"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classov__msckf_1_1StateHelper.html#a7a6d020115f02fe783ced90b90c32287">marginalize</a> (std::shared_ptr&lt; <a class="el" href="classov__msckf_1_1State.html">State</a> &gt; state, std::shared_ptr&lt; <a class="el" href="classov__type_1_1Type.html">ov_type::Type</a> &gt; marg)</td></tr>
<tr class="memdesc:a7a6d020115f02fe783ced90b90c32287"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marginalizes a variable, properly modifying the ordering/covariances in the state  <a href="#a7a6d020115f02fe783ced90b90c32287">更多...</a><br /></td></tr>
<tr class="separator:a7a6d020115f02fe783ced90b90c32287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aecb942a1d9bb7dec915fdad303acc8"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classov__type_1_1Type.html">ov_type::Type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classov__msckf_1_1StateHelper.html#a3aecb942a1d9bb7dec915fdad303acc8">clone</a> (std::shared_ptr&lt; <a class="el" href="classov__msckf_1_1State.html">State</a> &gt; state, std::shared_ptr&lt; <a class="el" href="classov__type_1_1Type.html">ov_type::Type</a> &gt; variable_to_clone)</td></tr>
<tr class="memdesc:a3aecb942a1d9bb7dec915fdad303acc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clones "variable to clone" and places it at end of covariance  <a href="#a3aecb942a1d9bb7dec915fdad303acc8">更多...</a><br /></td></tr>
<tr class="separator:a3aecb942a1d9bb7dec915fdad303acc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58ed364529ae3802a7110edf3ac4dbbb"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classov__msckf_1_1StateHelper.html#a58ed364529ae3802a7110edf3ac4dbbb">initialize</a> (std::shared_ptr&lt; <a class="el" href="classov__msckf_1_1State.html">State</a> &gt; state, std::shared_ptr&lt; <a class="el" href="classov__type_1_1Type.html">ov_type::Type</a> &gt; new_variable, const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classov__type_1_1Type.html">ov_type::Type</a> &gt;&gt; &amp;H_order, Eigen::MatrixXd &amp;H_R, Eigen::MatrixXd &amp;H_L, Eigen::MatrixXd &amp;R, Eigen::VectorXd &amp;res, double chi_2_mult)</td></tr>
<tr class="memdesc:a58ed364529ae3802a7110edf3ac4dbbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes new variable into covariance.  <a href="#a58ed364529ae3802a7110edf3ac4dbbb">更多...</a><br /></td></tr>
<tr class="separator:a58ed364529ae3802a7110edf3ac4dbbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0f34932bb91d89bfd5ae72c2e693d8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classov__msckf_1_1StateHelper.html#adb0f34932bb91d89bfd5ae72c2e693d8">initialize_invertible</a> (std::shared_ptr&lt; <a class="el" href="classov__msckf_1_1State.html">State</a> &gt; state, std::shared_ptr&lt; <a class="el" href="classov__type_1_1Type.html">ov_type::Type</a> &gt; new_variable, const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classov__type_1_1Type.html">ov_type::Type</a> &gt;&gt; &amp;H_order, const Eigen::MatrixXd &amp;H_R, const Eigen::MatrixXd &amp;H_L, const Eigen::MatrixXd &amp;R, const Eigen::VectorXd &amp;res)</td></tr>
<tr class="memdesc:adb0f34932bb91d89bfd5ae72c2e693d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes new variable into covariance (H_L must be invertible)  <a href="#adb0f34932bb91d89bfd5ae72c2e693d8">更多...</a><br /></td></tr>
<tr class="separator:adb0f34932bb91d89bfd5ae72c2e693d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade3a86a89f15cc6e03a6430fd1dee694"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classov__msckf_1_1StateHelper.html#ade3a86a89f15cc6e03a6430fd1dee694">augment_clone</a> (std::shared_ptr&lt; <a class="el" href="classov__msckf_1_1State.html">State</a> &gt; state, Eigen::Matrix&lt; double, 3, 1 &gt; last_w)</td></tr>
<tr class="memdesc:ade3a86a89f15cc6e03a6430fd1dee694"><td class="mdescLeft">&#160;</td><td class="mdescRight">Augment the state with a stochastic copy of the current IMU pose  <a href="#ade3a86a89f15cc6e03a6430fd1dee694">更多...</a><br /></td></tr>
<tr class="separator:ade3a86a89f15cc6e03a6430fd1dee694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18f86e6da0bf5e7d4879f8c2f1460a27"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classov__msckf_1_1StateHelper.html#a18f86e6da0bf5e7d4879f8c2f1460a27">marginalize_old_clone</a> (std::shared_ptr&lt; <a class="el" href="classov__msckf_1_1State.html">State</a> &gt; state)</td></tr>
<tr class="memdesc:a18f86e6da0bf5e7d4879f8c2f1460a27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the oldest clone, if we have more then the max clone count!!  <a href="#a18f86e6da0bf5e7d4879f8c2f1460a27">更多...</a><br /></td></tr>
<tr class="separator:a18f86e6da0bf5e7d4879f8c2f1460a27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54f8517a288b9362f29481f650f4b959"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classov__msckf_1_1StateHelper.html#a54f8517a288b9362f29481f650f4b959">marginalize_slam</a> (std::shared_ptr&lt; <a class="el" href="classov__msckf_1_1State.html">State</a> &gt; state)</td></tr>
<tr class="memdesc:a54f8517a288b9362f29481f650f4b959"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marginalize bad SLAM features  <a href="#a54f8517a288b9362f29481f650f4b959">更多...</a><br /></td></tr>
<tr class="separator:a54f8517a288b9362f29481f650f4b959"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">详细描述</h2>
<div class="textblock"><p>Helper which manipulates the <a class="el" href="classov__msckf_1_1State.html" title="State of our filter ">State</a> and its covariance. </p>
<p>In general, this class has all the core logic for an Extended Kalman Filter (EKF)-based system. This has all functions that change the covariance along with addition and removing elements from the state. All functions here are static, and thus are self-contained so that in the future multiple states could be tracked and updated. We recommend you look directly at the code for this class for clarity on what exactly we are doing in each and the matching documentation pages. </p>
</div><h2 class="groupheader">成员函数说明</h2>
<a id="ade3a86a89f15cc6e03a6430fd1dee694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade3a86a89f15cc6e03a6430fd1dee694">&#9670;&nbsp;</a></span>augment_clone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StateHelper::augment_clone </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classov__msckf_1_1State.html">State</a> &gt;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; double, 3, 1 &gt;&#160;</td>
          <td class="paramname"><em>last_w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Augment the state with a stochastic copy of the current IMU pose </p>
<p>After propagation, normally we augment the state with an new clone that is at the new update timestep. This augmentation clones the IMU pose and adds it to our state's clone map. If we are doing time offset calibration we also make our cloning a function of the time offset. Time offset logic is based on Mingyang Li and Anastasios I. Mourikis paper: <a href="http://journals.sagepub.com/doi/pdf/10.1177/0278364913515286">http://journals.sagepub.com/doi/pdf/10.1177/0278364913515286</a> We can write the current clone at the true imu base clock time as the follow: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} {}^{I_{t+t_d}}_G\bar{q} &amp;= \begin{bmatrix}\frac{1}{2} {}^{I_{t+\hat{t}_d}}\boldsymbol\omega \tilde{t}_d \\ 1\end{bmatrix}\otimes{}^{I_{t+\hat{t}_d}}_G\bar{q} \\ {}^G\mathbf{p}_{I_{t+t_d}} &amp;= {}^G\mathbf{p}_{I_{t+\hat{t}_d}} + {}^G\mathbf{v}_{I_{t+\hat{t}_d}}\tilde{t}_d \end{align*}" src="form_355.png"/>
</p>
<p> where we say that we have propagated our state up to the current estimated true imaging time for the current image, <img class="formulaInl" alt="${}^{I_{t+\hat{t}_d}}\boldsymbol\omega$" src="form_356.png"/> is the angular velocity at the end of propagation with biases removed. This is off by some smaller error, so to get to the true imaging time in the imu base clock, we can append some small timeoffset error. Thus the Jacobian in respect to our time offset during our cloning procedure is the following: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \frac{\partial {}^{I_{t+t_d}}_G\tilde{\boldsymbol\theta}}{\partial \tilde{t}_d} &amp;= {}^{I_{t+\hat{t}_d}}\boldsymbol\omega \\ \frac{\partial {}^G\tilde{\mathbf{p}}_{I_{t+t_d}}}{\partial \tilde{t}_d} &amp;= {}^G\mathbf{v}_{I_{t+\hat{t}_d}} \end{align*}" src="form_357.png"/>
</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>Pointer to state </td></tr>
    <tr><td class="paramname">last_w</td><td>The estimated angular velocity at cloning time (used to estimate imu-cam time offset) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3aecb942a1d9bb7dec915fdad303acc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aecb942a1d9bb7dec915fdad303acc8">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classov__type_1_1Type.html">Type</a> &gt; StateHelper::clone </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classov__msckf_1_1State.html">State</a> &gt;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classov__type_1_1Type.html">ov_type::Type</a> &gt;&#160;</td>
          <td class="paramname"><em>variable_to_clone</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clones "variable to clone" and places it at end of covariance </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>Pointer to state </td></tr>
    <tr><td class="paramname">variable_to_clone</td><td>Pointer to variable that will be cloned </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a31f92fdf5bac87bfc23d34334af7bd4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31f92fdf5bac87bfc23d34334af7bd4d">&#9670;&nbsp;</a></span>EKFPropagation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StateHelper::EKFPropagation </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classov__msckf_1_1State.html">State</a> &gt;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classov__type_1_1Type.html">ov_type::Type</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>order_NEW</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classov__type_1_1Type.html">ov_type::Type</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>order_OLD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>Phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>Q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs EKF propagation of the state covariance. </p>
<p>The mean of the state should already have been propagated, thus just moves the covariance forward in time. The new states that we are propagating the old covariance into, should be <b>contiguous</b> in memory. The user only needs to specify the sub-variables that this block is a function of. </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \tilde{\mathbf{x}}' = \begin{bmatrix} \boldsymbol\Phi_1 &amp; \boldsymbol\Phi_2 &amp; \boldsymbol\Phi_3 \end{bmatrix} \begin{bmatrix} \tilde{\mathbf{x}}_1 \\ \tilde{\mathbf{x}}_2 \\ \tilde{\mathbf{x}}_3 \end{bmatrix} + \mathbf{n} \]" src="form_354.png"/>
</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>Pointer to state </td></tr>
    <tr><td class="paramname">order_NEW</td><td>Contiguous variables that have evolved according to this state transition </td></tr>
    <tr><td class="paramname">order_OLD</td><td>Variable ordering used in the state transition </td></tr>
    <tr><td class="paramname">Phi</td><td><a class="el" href="classov__msckf_1_1State.html" title="State of our filter ">State</a> transition matrix (size order_NEW by size order_OLD) </td></tr>
    <tr><td class="paramname">Q</td><td>Additive state propagation noise matrix (size order_NEW by size order_NEW) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a471d81fcc22b706654556950931067fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a471d81fcc22b706654556950931067fd">&#9670;&nbsp;</a></span>EKFUpdate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StateHelper::EKFUpdate </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classov__msckf_1_1State.html">State</a> &gt;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classov__type_1_1Type.html">ov_type::Type</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>H_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs EKF update of the state (see <a class="el" href="update.html#linear-meas">Linear Measurement Update</a> page) </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>Pointer to state </td></tr>
    <tr><td class="paramname">H_order</td><td>Variable ordering used in the compressed Jacobian </td></tr>
    <tr><td class="paramname">H</td><td>Condensed Jacobian of updating measurement </td></tr>
    <tr><td class="paramname">res</td><td>residual of updating measurement </td></tr>
    <tr><td class="paramname">R</td><td>updating measurement covariance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ac98543816e664cd85e4fa61bd165b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ac98543816e664cd85e4fa61bd165b7">&#9670;&nbsp;</a></span>get_full_covariance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd StateHelper::get_full_covariance </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classov__msckf_1_1State.html">State</a> &gt;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This gets the full covariance matrix. </p>
<p>Should only be used during simulation as operations on this covariance will be slow. This will return a copy, so this cannot be used to change the covariance by design. Please use the other interface functions in the <a class="el" href="classov__msckf_1_1StateHelper.html" title="Helper which manipulates the State and its covariance. ">StateHelper</a> to progamatically change to covariance.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>Pointer to state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>covariance of current state </dd></dl>

</div>
</div>
<a id="a23ec77c8411dcc7cfed64273f6882805"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23ec77c8411dcc7cfed64273f6882805">&#9670;&nbsp;</a></span>get_marginal_covariance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd StateHelper::get_marginal_covariance </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classov__msckf_1_1State.html">State</a> &gt;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classov__type_1_1Type.html">ov_type::Type</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>small_variables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For a given set of variables, this will this will calculate a smaller covariance. </p>
<p>That only includes the ones specified with all crossterms. Thus the size of the return will be the summed dimension of all the passed variables. Normal use for this is a chi-squared check before update (where you don't need the full covariance).</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>Pointer to state </td></tr>
    <tr><td class="paramname">small_variables</td><td>Vector of variables whose marginal covariance is desired </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>marginal covariance of the passed variables </dd></dl>

</div>
</div>
<a id="a58ed364529ae3802a7110edf3ac4dbbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58ed364529ae3802a7110edf3ac4dbbb">&#9670;&nbsp;</a></span>initialize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool StateHelper::initialize </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classov__msckf_1_1State.html">State</a> &gt;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classov__type_1_1Type.html">ov_type::Type</a> &gt;&#160;</td>
          <td class="paramname"><em>new_variable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classov__type_1_1Type.html">ov_type::Type</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>H_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>H_R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>H_L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>chi_2_mult</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes new variable into covariance. </p>
<p>Uses Givens to separate into updating and initializing systems (therefore system must be fed as isotropic). If you are not isotropic first whiten your system (TODO: we should add a helper function to do this). If your H_L Jacobian is already directly invertable, the just call the <a class="el" href="classov__msckf_1_1StateHelper.html#adb0f34932bb91d89bfd5ae72c2e693d8" title="Initializes new variable into covariance (H_L must be invertible) ">initialize_invertible()</a> instead of this function. Please refer to <a class="el" href="update-delay.html">Delayed Feature Initialization</a> page for detailed derivation.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>Pointer to state </td></tr>
    <tr><td class="paramname">new_variable</td><td>Pointer to variable to be initialized </td></tr>
    <tr><td class="paramname">H_order</td><td>Vector of pointers in order they are contained in the condensed state Jacobian </td></tr>
    <tr><td class="paramname">H_R</td><td>Jacobian of initializing measurements wrt variables in H_order </td></tr>
    <tr><td class="paramname">H_L</td><td>Jacobian of initializing measurements wrt new variable </td></tr>
    <tr><td class="paramname">R</td><td>Covariance of initializing measurements (isotropic) </td></tr>
    <tr><td class="paramname">res</td><td>Residual of initializing measurements </td></tr>
    <tr><td class="paramname">chi_2_mult</td><td>Value we should multiply the chi2 threshold by (larger means it will be accepted more measurements) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb0f34932bb91d89bfd5ae72c2e693d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb0f34932bb91d89bfd5ae72c2e693d8">&#9670;&nbsp;</a></span>initialize_invertible()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StateHelper::initialize_invertible </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classov__msckf_1_1State.html">State</a> &gt;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classov__type_1_1Type.html">ov_type::Type</a> &gt;&#160;</td>
          <td class="paramname"><em>new_variable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classov__type_1_1Type.html">ov_type::Type</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>H_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>H_R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>H_L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes new variable into covariance (H_L must be invertible) </p>
<p>Please refer to <a class="el" href="update-delay.html">Delayed Feature Initialization</a> page for detailed derivation. This is just the update assuming that H_L is invertable (and thus square) and isotropic noise.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>Pointer to state </td></tr>
    <tr><td class="paramname">new_variable</td><td>Pointer to variable to be initialized </td></tr>
    <tr><td class="paramname">H_order</td><td>Vector of pointers in order they are contained in the condensed state Jacobian </td></tr>
    <tr><td class="paramname">H_R</td><td>Jacobian of initializing measurements wrt variables in H_order </td></tr>
    <tr><td class="paramname">H_L</td><td>Jacobian of initializing measurements wrt new variable (needs to be invertible) </td></tr>
    <tr><td class="paramname">R</td><td>Covariance of initializing measurements </td></tr>
    <tr><td class="paramname">res</td><td>Residual of initializing measurements </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a6d020115f02fe783ced90b90c32287"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a6d020115f02fe783ced90b90c32287">&#9670;&nbsp;</a></span>marginalize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StateHelper::marginalize </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classov__msckf_1_1State.html">State</a> &gt;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classov__type_1_1Type.html">ov_type::Type</a> &gt;&#160;</td>
          <td class="paramname"><em>marg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marginalizes a variable, properly modifying the ordering/covariances in the state </p>
<p>This function can support any Type variable out of the box. Right now the marginalization of a sub-variable/type is not supported. For example if you wanted to just marginalize the orientation of a PoseJPL, that isn't supported. We will first remove the rows and columns corresponding to the type (i.e. do the marginalization). After we update all the type ids so that they take into account that the covariance has shrunk in parts of it.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>Pointer to state </td></tr>
    <tr><td class="paramname">marg</td><td>Pointer to variable to marginalize </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a18f86e6da0bf5e7d4879f8c2f1460a27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18f86e6da0bf5e7d4879f8c2f1460a27">&#9670;&nbsp;</a></span>marginalize_old_clone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StateHelper::marginalize_old_clone </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classov__msckf_1_1State.html">State</a> &gt;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the oldest clone, if we have more then the max clone count!! </p>
<p>This will marginalize the clone from our covariance, and remove it from our state. This is mainly a helper function that we can call after each update. It will marginalize the clone specified by <a class="el" href="classov__msckf_1_1State.html#a36420e71ffa54625667eac2a8a345582" title="Will return the timestep that we will marginalize next. As of right now, since we are using a sliding...">State::margtimestep()</a> which should return a clone timestamp.</p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>Pointer to state </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a54f8517a288b9362f29481f650f4b959"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54f8517a288b9362f29481f650f4b959">&#9670;&nbsp;</a></span>marginalize_slam()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StateHelper::marginalize_slam </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classov__msckf_1_1State.html">State</a> &gt;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marginalize bad SLAM features </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>Pointer to state </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f19646a05e77e67d5be2da8aed19f14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f19646a05e77e67d5be2da8aed19f14">&#9670;&nbsp;</a></span>set_initial_covariance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StateHelper::set_initial_covariance </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classov__msckf_1_1State.html">State</a> &gt;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>covariance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classov__type_1_1Type.html">ov_type::Type</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This will set the initial covaraince of the specified state elements. Will also ensure that proper cross-covariances are inserted. </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>Pointer to state </td></tr>
    <tr><td class="paramname">covariance</td><td>The covariance of the system state </td></tr>
    <tr><td class="paramname">order</td><td>Order of the covariance matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
制作者 &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
