<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenVINS: ov_core::CamRadtan类 参考</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpenVINS
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'搜索');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','搜索');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceov__core.html">ov_core</a></li><li class="navelem"><a class="el" href="classov__core_1_1CamRadtan.html">CamRadtan</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public 成员函数</a> &#124;
<a href="classov__core_1_1CamRadtan-members.html">所有成员列表</a>  </div>
  <div class="headertitle">
<div class="title">ov_core::CamRadtan类 参考</div>  </div>
</div><!--header-->
<div class="contents">

<p>Radial-tangential / Brown–Conrady model pinhole camera model class  
 <a href="classov__core_1_1CamRadtan.html#details">更多...</a></p>

<p><code>#include &lt;<a class="el" href="CamRadtan_8h_source.html">CamRadtan.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public 成员函数</h2></td></tr>
<tr class="memitem:a34a91e335e1767f20e82cc6013a8ccc8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classov__core_1_1CamRadtan.html#a34a91e335e1767f20e82cc6013a8ccc8">CamRadtan</a> (int width, int height)</td></tr>
<tr class="memdesc:a34a91e335e1767f20e82cc6013a8ccc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor  <a href="#a34a91e335e1767f20e82cc6013a8ccc8">更多...</a><br /></td></tr>
<tr class="separator:a34a91e335e1767f20e82cc6013a8ccc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af02fa84ed2fdc895aaaf216184aa25ef"><td class="memItemLeft" align="right" valign="top">Eigen::Vector2f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classov__core_1_1CamRadtan.html#af02fa84ed2fdc895aaaf216184aa25ef">undistort_f</a> (const Eigen::Vector2f &amp;uv_dist) override</td></tr>
<tr class="memdesc:af02fa84ed2fdc895aaaf216184aa25ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a raw uv point, this will undistort it based on the camera matrices into normalized camera coords.  <a href="#af02fa84ed2fdc895aaaf216184aa25ef">更多...</a><br /></td></tr>
<tr class="separator:af02fa84ed2fdc895aaaf216184aa25ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a022376b5a15b827bbb7dabebc8df0508"><td class="memItemLeft" align="right" valign="top">Eigen::Vector2f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classov__core_1_1CamRadtan.html#a022376b5a15b827bbb7dabebc8df0508">distort_f</a> (const Eigen::Vector2f &amp;uv_norm) override</td></tr>
<tr class="memdesc:a022376b5a15b827bbb7dabebc8df0508"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a normalized uv coordinate this will distort it to the raw image plane  <a href="#a022376b5a15b827bbb7dabebc8df0508">更多...</a><br /></td></tr>
<tr class="separator:a022376b5a15b827bbb7dabebc8df0508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ab5e54e89f48779a696f5b33d120dbc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classov__core_1_1CamRadtan.html#a4ab5e54e89f48779a696f5b33d120dbc">compute_distort_jacobian</a> (const Eigen::Vector2d &amp;uv_norm, Eigen::MatrixXd &amp;H_dz_dzn, Eigen::MatrixXd &amp;H_dz_dzeta) override</td></tr>
<tr class="memdesc:a4ab5e54e89f48779a696f5b33d120dbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the derivative of raw distorted to normalized coordinate.  <a href="#a4ab5e54e89f48779a696f5b33d120dbc">更多...</a><br /></td></tr>
<tr class="separator:a4ab5e54e89f48779a696f5b33d120dbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classov__core_1_1CamBase"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classov__core_1_1CamBase')"><img src="closed.png" alt="-"/>&#160;Public 成员函数 继承自 <a class="el" href="classov__core_1_1CamBase.html">ov_core::CamBase</a></td></tr>
<tr class="memitem:a1f11a6e4e8324d6843b578c0dabe0f94 inherit pub_methods_classov__core_1_1CamBase"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classov__core_1_1CamBase.html#a1f11a6e4e8324d6843b578c0dabe0f94">CamBase</a> (int width, int height)</td></tr>
<tr class="memdesc:a1f11a6e4e8324d6843b578c0dabe0f94 inherit pub_methods_classov__core_1_1CamBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor  <a href="classov__core_1_1CamBase.html#a1f11a6e4e8324d6843b578c0dabe0f94">更多...</a><br /></td></tr>
<tr class="separator:a1f11a6e4e8324d6843b578c0dabe0f94 inherit pub_methods_classov__core_1_1CamBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a630f35e703c3893ae694fe0f14693216 inherit pub_methods_classov__core_1_1CamBase"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classov__core_1_1CamBase.html#a630f35e703c3893ae694fe0f14693216">set_value</a> (const Eigen::MatrixXd &amp;calib)</td></tr>
<tr class="memdesc:a630f35e703c3893ae694fe0f14693216 inherit pub_methods_classov__core_1_1CamBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This will set and update the camera calibration values. This should be called on startup for each camera and after update!  <a href="classov__core_1_1CamBase.html#a630f35e703c3893ae694fe0f14693216">更多...</a><br /></td></tr>
<tr class="separator:a630f35e703c3893ae694fe0f14693216 inherit pub_methods_classov__core_1_1CamBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab910cf55ee13ca74eb4b8463ab32f1c4 inherit pub_methods_classov__core_1_1CamBase"><td class="memItemLeft" align="right" valign="top">Eigen::Vector2d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classov__core_1_1CamBase.html#ab910cf55ee13ca74eb4b8463ab32f1c4">undistort_d</a> (const Eigen::Vector2d &amp;uv_dist)</td></tr>
<tr class="memdesc:ab910cf55ee13ca74eb4b8463ab32f1c4 inherit pub_methods_classov__core_1_1CamBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a raw uv point, this will undistort it based on the camera matrices into normalized camera coords.  <a href="classov__core_1_1CamBase.html#ab910cf55ee13ca74eb4b8463ab32f1c4">更多...</a><br /></td></tr>
<tr class="separator:ab910cf55ee13ca74eb4b8463ab32f1c4 inherit pub_methods_classov__core_1_1CamBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42b140a7dfc1398cc7fc2f8df6c141d2 inherit pub_methods_classov__core_1_1CamBase"><td class="memItemLeft" align="right" valign="top">cv::Point2f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classov__core_1_1CamBase.html#a42b140a7dfc1398cc7fc2f8df6c141d2">undistort_cv</a> (const cv::Point2f &amp;uv_dist)</td></tr>
<tr class="memdesc:a42b140a7dfc1398cc7fc2f8df6c141d2 inherit pub_methods_classov__core_1_1CamBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a raw uv point, this will undistort it based on the camera matrices into normalized camera coords.  <a href="classov__core_1_1CamBase.html#a42b140a7dfc1398cc7fc2f8df6c141d2">更多...</a><br /></td></tr>
<tr class="separator:a42b140a7dfc1398cc7fc2f8df6c141d2 inherit pub_methods_classov__core_1_1CamBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf981dbc008c5929bf32ddde80b04caf inherit pub_methods_classov__core_1_1CamBase"><td class="memItemLeft" align="right" valign="top">Eigen::Vector2d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classov__core_1_1CamBase.html#acf981dbc008c5929bf32ddde80b04caf">distort_d</a> (const Eigen::Vector2d &amp;uv_norm)</td></tr>
<tr class="memdesc:acf981dbc008c5929bf32ddde80b04caf inherit pub_methods_classov__core_1_1CamBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a normalized uv coordinate this will distort it to the raw image plane  <a href="classov__core_1_1CamBase.html#acf981dbc008c5929bf32ddde80b04caf">更多...</a><br /></td></tr>
<tr class="separator:acf981dbc008c5929bf32ddde80b04caf inherit pub_methods_classov__core_1_1CamBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae04e8fb6f5b61a7c9e9b7c22cfc1b82c inherit pub_methods_classov__core_1_1CamBase"><td class="memItemLeft" align="right" valign="top">cv::Point2f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classov__core_1_1CamBase.html#ae04e8fb6f5b61a7c9e9b7c22cfc1b82c">distort_cv</a> (const cv::Point2f &amp;uv_norm)</td></tr>
<tr class="memdesc:ae04e8fb6f5b61a7c9e9b7c22cfc1b82c inherit pub_methods_classov__core_1_1CamBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a normalized uv coordinate this will distort it to the raw image plane  <a href="classov__core_1_1CamBase.html#ae04e8fb6f5b61a7c9e9b7c22cfc1b82c">更多...</a><br /></td></tr>
<tr class="separator:ae04e8fb6f5b61a7c9e9b7c22cfc1b82c inherit pub_methods_classov__core_1_1CamBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8c2283f7db1a88b590c8058e8949150 inherit pub_methods_classov__core_1_1CamBase"><td class="memItemLeft" align="right" valign="top"><a id="aa8c2283f7db1a88b590c8058e8949150"></a>
Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classov__core_1_1CamBase.html#aa8c2283f7db1a88b590c8058e8949150">get_value</a> ()</td></tr>
<tr class="memdesc:aa8c2283f7db1a88b590c8058e8949150 inherit pub_methods_classov__core_1_1CamBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the complete intrinsic vector <br /></td></tr>
<tr class="separator:aa8c2283f7db1a88b590c8058e8949150 inherit pub_methods_classov__core_1_1CamBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b8c0f89bf1bde983806b1dc331658c inherit pub_methods_classov__core_1_1CamBase"><td class="memItemLeft" align="right" valign="top"><a id="a01b8c0f89bf1bde983806b1dc331658c"></a>
cv::Matx33d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classov__core_1_1CamBase.html#a01b8c0f89bf1bde983806b1dc331658c">get_K</a> ()</td></tr>
<tr class="memdesc:a01b8c0f89bf1bde983806b1dc331658c inherit pub_methods_classov__core_1_1CamBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the camera matrix <br /></td></tr>
<tr class="separator:a01b8c0f89bf1bde983806b1dc331658c inherit pub_methods_classov__core_1_1CamBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ee1a5a19bf68bbf7bcd55dcd56748fb inherit pub_methods_classov__core_1_1CamBase"><td class="memItemLeft" align="right" valign="top"><a id="a7ee1a5a19bf68bbf7bcd55dcd56748fb"></a>
cv::Vec4d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classov__core_1_1CamBase.html#a7ee1a5a19bf68bbf7bcd55dcd56748fb">get_D</a> ()</td></tr>
<tr class="memdesc:a7ee1a5a19bf68bbf7bcd55dcd56748fb inherit pub_methods_classov__core_1_1CamBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the camera distortion <br /></td></tr>
<tr class="separator:a7ee1a5a19bf68bbf7bcd55dcd56748fb inherit pub_methods_classov__core_1_1CamBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eea297b76bc8acfe69946699b83d4f5 inherit pub_methods_classov__core_1_1CamBase"><td class="memItemLeft" align="right" valign="top"><a id="a9eea297b76bc8acfe69946699b83d4f5"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classov__core_1_1CamBase.html#a9eea297b76bc8acfe69946699b83d4f5">w</a> ()</td></tr>
<tr class="memdesc:a9eea297b76bc8acfe69946699b83d4f5 inherit pub_methods_classov__core_1_1CamBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the width of the camera images <br /></td></tr>
<tr class="separator:a9eea297b76bc8acfe69946699b83d4f5 inherit pub_methods_classov__core_1_1CamBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa159148b3d1b3789f68c61ca54084e2a inherit pub_methods_classov__core_1_1CamBase"><td class="memItemLeft" align="right" valign="top"><a id="aa159148b3d1b3789f68c61ca54084e2a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classov__core_1_1CamBase.html#aa159148b3d1b3789f68c61ca54084e2a">h</a> ()</td></tr>
<tr class="memdesc:aa159148b3d1b3789f68c61ca54084e2a inherit pub_methods_classov__core_1_1CamBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the height of the camera images <br /></td></tr>
<tr class="separator:aa159148b3d1b3789f68c61ca54084e2a inherit pub_methods_classov__core_1_1CamBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
额外继承的成员函数</h2></td></tr>
<tr class="inherit_header pro_attribs_classov__core_1_1CamBase"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classov__core_1_1CamBase')"><img src="closed.png" alt="-"/>&#160;Protected 属性 继承自 <a class="el" href="classov__core_1_1CamBase.html">ov_core::CamBase</a></td></tr>
<tr class="memitem:a3b9b353487071aef189fc5bc313dab5d inherit pro_attribs_classov__core_1_1CamBase"><td class="memItemLeft" align="right" valign="top"><a id="a3b9b353487071aef189fc5bc313dab5d"></a>
Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classov__core_1_1CamBase.html#a3b9b353487071aef189fc5bc313dab5d">camera_values</a></td></tr>
<tr class="memdesc:a3b9b353487071aef189fc5bc313dab5d inherit pro_attribs_classov__core_1_1CamBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raw set of camera intrinic values (f_x &amp; f_y &amp; c_x &amp; c_y &amp; k_1 &amp; k_2 &amp; k_3 &amp; k_4) <br /></td></tr>
<tr class="separator:a3b9b353487071aef189fc5bc313dab5d inherit pro_attribs_classov__core_1_1CamBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a867f7b5a903cc2776227c9b16fdde162 inherit pro_attribs_classov__core_1_1CamBase"><td class="memItemLeft" align="right" valign="top"><a id="a867f7b5a903cc2776227c9b16fdde162"></a>
cv::Matx33d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classov__core_1_1CamBase.html#a867f7b5a903cc2776227c9b16fdde162">camera_k_OPENCV</a></td></tr>
<tr class="memdesc:a867f7b5a903cc2776227c9b16fdde162 inherit pro_attribs_classov__core_1_1CamBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Camera intrinsics in OpenCV format <br /></td></tr>
<tr class="separator:a867f7b5a903cc2776227c9b16fdde162 inherit pro_attribs_classov__core_1_1CamBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5783a122e28281c1cd72a23f4bee212c inherit pro_attribs_classov__core_1_1CamBase"><td class="memItemLeft" align="right" valign="top"><a id="a5783a122e28281c1cd72a23f4bee212c"></a>
cv::Vec4d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classov__core_1_1CamBase.html#a5783a122e28281c1cd72a23f4bee212c">camera_d_OPENCV</a></td></tr>
<tr class="memdesc:a5783a122e28281c1cd72a23f4bee212c inherit pro_attribs_classov__core_1_1CamBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Camera distortion in OpenCV format <br /></td></tr>
<tr class="separator:a5783a122e28281c1cd72a23f4bee212c inherit pro_attribs_classov__core_1_1CamBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7b9e38e6da0ee85af5f82c3bc3ea91d inherit pro_attribs_classov__core_1_1CamBase"><td class="memItemLeft" align="right" valign="top"><a id="aa7b9e38e6da0ee85af5f82c3bc3ea91d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classov__core_1_1CamBase.html#aa7b9e38e6da0ee85af5f82c3bc3ea91d">_width</a></td></tr>
<tr class="memdesc:aa7b9e38e6da0ee85af5f82c3bc3ea91d inherit pro_attribs_classov__core_1_1CamBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Width of the camera (raw pixels) <br /></td></tr>
<tr class="separator:aa7b9e38e6da0ee85af5f82c3bc3ea91d inherit pro_attribs_classov__core_1_1CamBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9d833d887ee0ca92044e72d788c54de inherit pro_attribs_classov__core_1_1CamBase"><td class="memItemLeft" align="right" valign="top"><a id="aa9d833d887ee0ca92044e72d788c54de"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classov__core_1_1CamBase.html#aa9d833d887ee0ca92044e72d788c54de">_height</a></td></tr>
<tr class="memdesc:aa9d833d887ee0ca92044e72d788c54de inherit pro_attribs_classov__core_1_1CamBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Height of the camera (raw pixels) <br /></td></tr>
<tr class="separator:aa9d833d887ee0ca92044e72d788c54de inherit pro_attribs_classov__core_1_1CamBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">详细描述</h2>
<div class="textblock"><p>Radial-tangential / Brown–Conrady model pinhole camera model class </p>
<p>To calibrate camera intrinsics, we need to know how to map our normalized coordinates into the raw pixel coordinates on the image plane. We first employ the radial distortion as in <a href="https://docs.opencv.org/3.4/da/d54/group__imgproc__transform.html#details">OpenCV model</a>:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \begin{bmatrix} u \\ v \end{bmatrix}:= \mathbf{z}_k &amp;= \mathbf h_d(\mathbf{z}_{n,k}, ~\boldsymbol\zeta) = \begin{bmatrix} f_x * x + c_x \\ f_y * y + c_y \end{bmatrix}\\[1em] \empty {\rm where}~~ x &amp;= x_n (1 + k_1 r^2 + k_2 r^4) + 2 p_1 x_n y_n + p_2(r^2 + 2 x_n^2) \\\ y &amp;= y_n (1 + k_1 r^2 + k_2 r^4) + p_1 (r^2 + 2 y_n^2) + 2 p_2 x_n y_n \\[1em] r^2 &amp;= x_n^2 + y_n^2 \end{align*}" src="form_185.png"/>
</p>
<p>where <img class="formulaInl" alt="$ \mathbf{z}_{n,k} = [ x_n ~ y_n ]^\top$" src="form_186.png"/> are the normalized coordinates of the 3D feature and u and v are the distorted image coordinates on the image plane. The following distortion and camera intrinsic (focal length and image center) parameters are involved in the above distortion model, which can be estimated online:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \boldsymbol\zeta = \begin{bmatrix} f_x &amp; f_y &amp; c_x &amp; c_y &amp; k_1 &amp; k_2 &amp; p_1 &amp; p_2 \end{bmatrix}^\top \end{align*}" src="form_187.png"/>
</p>
<p>Note that we do not estimate the higher order (i.e., higher than fourth order) terms as in most offline calibration methods such as <a href="https://github.com/ethz-asl/kalibr">Kalibr</a>. To estimate these intrinsic parameters (including the distortation parameters), the following Jacobian for these parameters is needed:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \frac{\partial \mathbf h_d(\cdot)}{\partial \boldsymbol\zeta} = \begin{bmatrix} x &amp; 0 &amp; 1 &amp; 0 &amp; f_x*(x_nr^2) &amp; f_x*(x_nr^4) &amp; f_x*(2x_ny_n) &amp; f_x*(r^2+2x_n^2) \\[5pt] 0 &amp; y &amp; 0 &amp; 1 &amp; f_y*(y_nr^2) &amp; f_y*(y_nr^4) &amp; f_y*(r^2+2y_n^2) &amp; f_y*(2x_ny_n) \end{bmatrix} \end{align*}" src="form_188.png"/>
</p>
<p>Similarly, the Jacobian with respect to the normalized coordinates can be obtained as follows:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \frac{\partial \mathbf h_d (\cdot)}{\partial \mathbf{z}_{n,k}} = \begin{bmatrix} f_x*((1+k_1r^2+k_2r^4)+(2k_1x_n^2+4k_2x_n^2(x_n^2+y_n^2))+2p_1y_n+(2p_2x_n+4p_2x_n)) &amp; f_x*(2k_1x_ny_n+4k_2x_ny_n(x_n^2+y_n^2)+2p_1x_n+2p_2y_n) \\ f_y*(2k_1x_ny_n+4k_2x_ny_n(x_n^2+y_n^2)+2p_1x_n+2p_2y_n) &amp; f_y*((1+k_1r^2+k_2r^4)+(2k_1y_n^2+4k_2y_n^2(x_n^2+y_n^2))+(2p_1y_n+4p_1y_n)+2p_2x_n) \end{bmatrix} \end{align*}" src="form_189.png"/>
</p>
<p>To equate this camera class to Kalibr's models, this is what you would use for <code>pinhole-radtan</code>. </p>
</div><h2 class="groupheader">构造及析构函数说明</h2>
<a id="a34a91e335e1767f20e82cc6013a8ccc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34a91e335e1767f20e82cc6013a8ccc8">&#9670;&nbsp;</a></span>CamRadtan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ov_core::CamRadtan::CamRadtan </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>Width of the camera (raw pixels) </td></tr>
    <tr><td class="paramname">height</td><td>Height of the camera (raw pixels) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">成员函数说明</h2>
<a id="a4ab5e54e89f48779a696f5b33d120dbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ab5e54e89f48779a696f5b33d120dbc">&#9670;&nbsp;</a></span>compute_distort_jacobian()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ov_core::CamRadtan::compute_distort_jacobian </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector2d &amp;&#160;</td>
          <td class="paramname"><em>uv_norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>H_dz_dzn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>H_dz_dzeta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the derivative of raw distorted to normalized coordinate. </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">uv_norm</td><td>Normalized coordinates we wish to distort </td></tr>
    <tr><td class="paramname">H_dz_dzn</td><td>Derivative of measurement z in respect to normalized </td></tr>
    <tr><td class="paramname">H_dz_dzeta</td><td>Derivative of measurement z in respect to intrinic parameters </td></tr>
  </table>
  </dd>
</dl>

<p>实现了 <a class="el" href="classov__core_1_1CamBase.html#a498fa2b56be008d7b59bf9927f60d5db">ov_core::CamBase</a>.</p>

</div>
</div>
<a id="a022376b5a15b827bbb7dabebc8df0508"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a022376b5a15b827bbb7dabebc8df0508">&#9670;&nbsp;</a></span>distort_f()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Vector2f ov_core::CamRadtan::distort_f </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector2f &amp;&#160;</td>
          <td class="paramname"><em>uv_norm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a normalized uv coordinate this will distort it to the raw image plane </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">uv_norm</td><td>Normalized coordinates we wish to distort </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>2d vector of raw uv coordinate </dd></dl>

<p>实现了 <a class="el" href="classov__core_1_1CamBase.html#a00902793219107474dc21f762fb14556">ov_core::CamBase</a>.</p>

</div>
</div>
<a id="af02fa84ed2fdc895aaaf216184aa25ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af02fa84ed2fdc895aaaf216184aa25ef">&#9670;&nbsp;</a></span>undistort_f()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Vector2f ov_core::CamRadtan::undistort_f </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector2f &amp;&#160;</td>
          <td class="paramname"><em>uv_dist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a raw uv point, this will undistort it based on the camera matrices into normalized camera coords. </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">uv_dist</td><td>Raw uv coordinate we wish to undistort </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>2d vector of normalized coordinates </dd></dl>

<p>实现了 <a class="el" href="classov__core_1_1CamBase.html#ad0db03f97e5a12f5ad757f72e60f50e4">ov_core::CamBase</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
制作者 &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
