<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenVINS: ov_msckf::Propagator Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpenVINS
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceov__msckf.html">ov_msckf</a></li><li class="navelem"><a class="el" href="classov__msckf_1_1Propagator.html">Propagator</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classov__msckf_1_1Propagator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ov_msckf::Propagator Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Performs the state covariance and mean propagation using imu measurements.  
 <a href="classov__msckf_1_1Propagator.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Propagator_8h_source.html">Propagator.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a041751e94b04af4134c31a5f32c58d47"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classov__msckf_1_1Propagator.html#a041751e94b04af4134c31a5f32c58d47">Propagator</a> (<a class="el" href="structov__msckf_1_1NoiseManager.html">NoiseManager</a> noises, double gravity_mag)</td></tr>
<tr class="memdesc:a041751e94b04af4134c31a5f32c58d47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a041751e94b04af4134c31a5f32c58d47">More...</a><br /></td></tr>
<tr class="separator:a041751e94b04af4134c31a5f32c58d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9badf8180a77869e6027d359af8121e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classov__msckf_1_1Propagator.html#aa9badf8180a77869e6027d359af8121e">feed_imu</a> (const <a class="el" href="structov__core_1_1ImuData.html">ov_core::ImuData</a> &amp;message, double oldest_time=-1)</td></tr>
<tr class="memdesc:aa9badf8180a77869e6027d359af8121e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores incoming inertial readings.  <a href="#aa9badf8180a77869e6027d359af8121e">More...</a><br /></td></tr>
<tr class="separator:aa9badf8180a77869e6027d359af8121e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac96e7c40b696501a1f68097e10dde319"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classov__msckf_1_1Propagator.html#ac96e7c40b696501a1f68097e10dde319">propagate_and_clone</a> (std::shared_ptr&lt; <a class="el" href="classov__msckf_1_1State.html">State</a> &gt; state, double timestamp)</td></tr>
<tr class="memdesc:ac96e7c40b696501a1f68097e10dde319"><td class="mdescLeft">&#160;</td><td class="mdescRight">Propagate state up to given timestamp and then clone.  <a href="#ac96e7c40b696501a1f68097e10dde319">More...</a><br /></td></tr>
<tr class="separator:ac96e7c40b696501a1f68097e10dde319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33aabf2aea886a848a5ea3f6d83be4a4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classov__msckf_1_1Propagator.html#a33aabf2aea886a848a5ea3f6d83be4a4">fast_state_propagate</a> (std::shared_ptr&lt; <a class="el" href="classov__msckf_1_1State.html">State</a> &gt; state, double timestamp, Eigen::Matrix&lt; double, 13, 1 &gt; &amp;state_plus, Eigen::Matrix&lt; double, 12, 12 &gt; &amp;covariance)</td></tr>
<tr class="memdesc:a33aabf2aea886a848a5ea3f6d83be4a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets what the state and its covariance will be at a given timestamp.  <a href="#a33aabf2aea886a848a5ea3f6d83be4a4">More...</a><br /></td></tr>
<tr class="separator:a33aabf2aea886a848a5ea3f6d83be4a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a2f2d18be72bfc40bab5ae5eab2bae10e"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; <a class="el" href="structov__core_1_1ImuData.html">ov_core::ImuData</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classov__msckf_1_1Propagator.html#a2f2d18be72bfc40bab5ae5eab2bae10e">select_imu_readings</a> (const std::vector&lt; <a class="el" href="structov__core_1_1ImuData.html">ov_core::ImuData</a> &gt; &amp;<a class="el" href="classov__msckf_1_1Propagator.html#aa1639a14dc1149d2e47be177bf33b572">imu_data</a>, double time0, double time1, bool warn=true)</td></tr>
<tr class="memdesc:a2f2d18be72bfc40bab5ae5eab2bae10e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function that given current imu data, will select imu readings between the two times.  <a href="#a2f2d18be72bfc40bab5ae5eab2bae10e">More...</a><br /></td></tr>
<tr class="separator:a2f2d18be72bfc40bab5ae5eab2bae10e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dde6d888eec85594aa6a864d141d5dc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structov__core_1_1ImuData.html">ov_core::ImuData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classov__msckf_1_1Propagator.html#a3dde6d888eec85594aa6a864d141d5dc">interpolate_data</a> (const <a class="el" href="structov__core_1_1ImuData.html">ov_core::ImuData</a> &amp;imu_1, const <a class="el" href="structov__core_1_1ImuData.html">ov_core::ImuData</a> &amp;imu_2, double timestamp)</td></tr>
<tr class="memdesc:a3dde6d888eec85594aa6a864d141d5dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nice helper function that will linearly interpolate between two imu messages.  <a href="#a3dde6d888eec85594aa6a864d141d5dc">More...</a><br /></td></tr>
<tr class="separator:a3dde6d888eec85594aa6a864d141d5dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a3e7cfb88ec2c5eb7e090e0e6fe48225e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classov__msckf_1_1Propagator.html#a3e7cfb88ec2c5eb7e090e0e6fe48225e">predict_and_compute</a> (std::shared_ptr&lt; <a class="el" href="classov__msckf_1_1State.html">State</a> &gt; state, const <a class="el" href="structov__core_1_1ImuData.html">ov_core::ImuData</a> &amp;data_minus, const <a class="el" href="structov__core_1_1ImuData.html">ov_core::ImuData</a> &amp;data_plus, Eigen::Matrix&lt; double, 15, 15 &gt; &amp;F, Eigen::Matrix&lt; double, 15, 15 &gt; &amp;Qd)</td></tr>
<tr class="memdesc:a3e7cfb88ec2c5eb7e090e0e6fe48225e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Propagates the state forward using the imu data and computes the noise covariance and state-transition matrix of this interval.  <a href="#a3e7cfb88ec2c5eb7e090e0e6fe48225e">More...</a><br /></td></tr>
<tr class="separator:a3e7cfb88ec2c5eb7e090e0e6fe48225e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a038285deaa51724081651471a8de298f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classov__msckf_1_1Propagator.html#a038285deaa51724081651471a8de298f">predict_mean_discrete</a> (std::shared_ptr&lt; <a class="el" href="classov__msckf_1_1State.html">State</a> &gt; state, double dt, const Eigen::Vector3d &amp;w_hat1, const Eigen::Vector3d &amp;a_hat1, const Eigen::Vector3d &amp;w_hat2, const Eigen::Vector3d &amp;a_hat2, Eigen::Vector4d &amp;new_q, Eigen::Vector3d &amp;new_v, Eigen::Vector3d &amp;new_p)</td></tr>
<tr class="memdesc:a038285deaa51724081651471a8de298f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discrete imu mean propagation.  <a href="#a038285deaa51724081651471a8de298f">More...</a><br /></td></tr>
<tr class="separator:a038285deaa51724081651471a8de298f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfc8dcea867622ef57e740e5ab884538"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classov__msckf_1_1Propagator.html#abfc8dcea867622ef57e740e5ab884538">predict_mean_rk4</a> (std::shared_ptr&lt; <a class="el" href="classov__msckf_1_1State.html">State</a> &gt; state, double dt, const Eigen::Vector3d &amp;w_hat1, const Eigen::Vector3d &amp;a_hat1, const Eigen::Vector3d &amp;w_hat2, const Eigen::Vector3d &amp;a_hat2, Eigen::Vector4d &amp;new_q, Eigen::Vector3d &amp;new_v, Eigen::Vector3d &amp;new_p)</td></tr>
<tr class="memdesc:abfc8dcea867622ef57e740e5ab884538"><td class="mdescLeft">&#160;</td><td class="mdescRight">RK4 imu mean propagation.  <a href="#abfc8dcea867622ef57e740e5ab884538">More...</a><br /></td></tr>
<tr class="separator:abfc8dcea867622ef57e740e5ab884538"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a2199da5257d46ee711371550c734dc9a"><td class="memItemLeft" align="right" valign="top"><a id="a2199da5257d46ee711371550c734dc9a"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classov__msckf_1_1Propagator.html#a2199da5257d46ee711371550c734dc9a">last_prop_time_offset</a> = 0.0</td></tr>
<tr class="memdesc:a2199da5257d46ee711371550c734dc9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimate for time offset at last propagation time. <br /></td></tr>
<tr class="separator:a2199da5257d46ee711371550c734dc9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7affb32669bf959625b65fb80a9af6a2"><td class="memItemLeft" align="right" valign="top"><a id="a7affb32669bf959625b65fb80a9af6a2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>have_last_prop_time_offset</b> = false</td></tr>
<tr class="separator:a7affb32669bf959625b65fb80a9af6a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f19a5f9fdb86733cfb0dcc040313f38"><td class="memItemLeft" align="right" valign="top"><a id="a3f19a5f9fdb86733cfb0dcc040313f38"></a>
<a class="el" href="structov__msckf_1_1NoiseManager.html">NoiseManager</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classov__msckf_1_1Propagator.html#a3f19a5f9fdb86733cfb0dcc040313f38">_noises</a></td></tr>
<tr class="memdesc:a3f19a5f9fdb86733cfb0dcc040313f38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for the noise values. <br /></td></tr>
<tr class="separator:a3f19a5f9fdb86733cfb0dcc040313f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1639a14dc1149d2e47be177bf33b572"><td class="memItemLeft" align="right" valign="top"><a id="aa1639a14dc1149d2e47be177bf33b572"></a>
std::vector&lt; <a class="el" href="structov__core_1_1ImuData.html">ov_core::ImuData</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classov__msckf_1_1Propagator.html#aa1639a14dc1149d2e47be177bf33b572">imu_data</a></td></tr>
<tr class="memdesc:aa1639a14dc1149d2e47be177bf33b572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Our history of IMU messages (time, angular, linear) <br /></td></tr>
<tr class="separator:aa1639a14dc1149d2e47be177bf33b572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9495dd802925abfde162f280f8f9d325"><td class="memItemLeft" align="right" valign="top"><a id="a9495dd802925abfde162f280f8f9d325"></a>
std::mutex&#160;</td><td class="memItemRight" valign="bottom"><b>imu_data_mtx</b></td></tr>
<tr class="separator:a9495dd802925abfde162f280f8f9d325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5ea009315ab578b48f079d502f97ab"><td class="memItemLeft" align="right" valign="top"><a id="a6a5ea009315ab578b48f079d502f97ab"></a>
Eigen::Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classov__msckf_1_1Propagator.html#a6a5ea009315ab578b48f079d502f97ab">_gravity</a></td></tr>
<tr class="memdesc:a6a5ea009315ab578b48f079d502f97ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gravity vector. <br /></td></tr>
<tr class="separator:a6a5ea009315ab578b48f079d502f97ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Performs the state covariance and mean propagation using imu measurements. </p>
<p>We will first select what measurements we need to propagate with. We then compute the state transition matrix at each step and update the state and covariance. For derivations look at <a class="el" href="propagation.html">IMU Propagation Derivations</a> page which has detailed equations. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a041751e94b04af4134c31a5f32c58d47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a041751e94b04af4134c31a5f32c58d47">&#9670;&nbsp;</a></span>Propagator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ov_msckf::Propagator::Propagator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structov__msckf_1_1NoiseManager.html">NoiseManager</a>&#160;</td>
          <td class="paramname"><em>noises</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>gravity_mag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">noises</td><td>imu noise characteristics (continuous time) </td></tr>
    <tr><td class="paramname">gravity_mag</td><td>Global gravity magnitude of the system (normally 9.81) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a33aabf2aea886a848a5ea3f6d83be4a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33aabf2aea886a848a5ea3f6d83be4a4">&#9670;&nbsp;</a></span>fast_state_propagate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Propagator::fast_state_propagate </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classov__msckf_1_1State.html">State</a> &gt;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timestamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; double, 13, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>state_plus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; double, 12, 12 &gt; &amp;&#160;</td>
          <td class="paramname"><em>covariance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets what the state and its covariance will be at a given timestamp. </p>
<p>This can be used to find what the state will be in the "future" without propagating it. This will propagate a clone of the current IMU state and its covariance matrix. This is typically used to provide high frequency pose estimates between updates.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>Pointer to state </td></tr>
    <tr><td class="paramname">timestamp</td><td>Time to propagate to (IMU clock frame) </td></tr>
    <tr><td class="paramname">state_plus</td><td>The propagated state (q_GtoI, p_IinG, v_IinI, w_IinI) </td></tr>
    <tr><td class="paramname">covariance</td><td>The propagated covariance (q_GtoI, p_IinG, v_IinI, w_IinI) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if we were able to propagate the state to the current timestep </dd></dl>

</div>
</div>
<a id="aa9badf8180a77869e6027d359af8121e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9badf8180a77869e6027d359af8121e">&#9670;&nbsp;</a></span>feed_imu()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ov_msckf::Propagator::feed_imu </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structov__core_1_1ImuData.html">ov_core::ImuData</a> &amp;&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>oldest_time</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores incoming inertial readings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>Contains our timestamp and inertial information </td></tr>
    <tr><td class="paramname">oldest_time</td><td>Time that we can discard measurements before </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3dde6d888eec85594aa6a864d141d5dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dde6d888eec85594aa6a864d141d5dc">&#9670;&nbsp;</a></span>interpolate_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structov__core_1_1ImuData.html">ov_core::ImuData</a> ov_msckf::Propagator::interpolate_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structov__core_1_1ImuData.html">ov_core::ImuData</a> &amp;&#160;</td>
          <td class="paramname"><em>imu_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structov__core_1_1ImuData.html">ov_core::ImuData</a> &amp;&#160;</td>
          <td class="paramname"><em>imu_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timestamp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Nice helper function that will linearly interpolate between two imu messages. </p>
<p>This should be used instead of just "cutting" imu messages that bound the camera times Give better time offset if we use this function, could try other orders/splines if the imu is slow.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">imu_1</td><td>imu at begining of interpolation interval </td></tr>
    <tr><td class="paramname">imu_2</td><td>imu at end of interpolation interval </td></tr>
    <tr><td class="paramname">timestamp</td><td>Timestamp being interpolated to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e7cfb88ec2c5eb7e090e0e6fe48225e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e7cfb88ec2c5eb7e090e0e6fe48225e">&#9670;&nbsp;</a></span>predict_and_compute()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Propagator::predict_and_compute </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classov__msckf_1_1State.html">State</a> &gt;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structov__core_1_1ImuData.html">ov_core::ImuData</a> &amp;&#160;</td>
          <td class="paramname"><em>data_minus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structov__core_1_1ImuData.html">ov_core::ImuData</a> &amp;&#160;</td>
          <td class="paramname"><em>data_plus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; double, 15, 15 &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; double, 15, 15 &gt; &amp;&#160;</td>
          <td class="paramname"><em>Qd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Propagates the state forward using the imu data and computes the noise covariance and state-transition matrix of this interval. </p>
<p>This function can be replaced with analytical/numerical integration or when using a different state representation. This contains our state transition matrix along with how our noise evolves in time. If you have other state variables besides the IMU that evolve you would add them here. See the <a class="el" href="propagation.html#error_prop">Discrete-time Error-state Propagation</a> page for details on how this was derived.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>Pointer to state </td></tr>
    <tr><td class="paramname">data_minus</td><td>imu readings at beginning of interval </td></tr>
    <tr><td class="paramname">data_plus</td><td>imu readings at end of interval </td></tr>
    <tr><td class="paramname">F</td><td>State-transition matrix over the interval </td></tr>
    <tr><td class="paramname">Qd</td><td>Discrete-time noise covariance over the interval </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a038285deaa51724081651471a8de298f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a038285deaa51724081651471a8de298f">&#9670;&nbsp;</a></span>predict_mean_discrete()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Propagator::predict_mean_discrete </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classov__msckf_1_1State.html">State</a> &gt;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>w_hat1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>a_hat1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>w_hat2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>a_hat2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector4d &amp;&#160;</td>
          <td class="paramname"><em>new_q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>new_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>new_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Discrete imu mean propagation. </p>
<p>See <a class="el" href="propagation.html">IMU Propagation Derivations</a> for details on these equations. </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \text{}^{I_{k+1}}_{G}\hat{\bar{q}} &amp;= \exp\bigg(\frac{1}{2}\boldsymbol{\Omega}\big({\boldsymbol{\omega}}_{m,k}-\hat{\mathbf{b}}_{g,k}\big)\Delta t\bigg) \text{}^{I_{k}}_{G}\hat{\bar{q}} \\ ^G\hat{\mathbf{v}}_{k+1} &amp;= \text{}^G\hat{\mathbf{v}}_{I_k} - {}^G\mathbf{g}\Delta t +\text{}^{I_k}_G\hat{\mathbf{R}}^\top(\mathbf{a}_{m,k} - \hat{\mathbf{b}}_{\mathbf{a},k})\Delta t\\ ^G\hat{\mathbf{p}}_{I_{k+1}} &amp;= \text{}^G\hat{\mathbf{p}}_{I_k} + {}^G\hat{\mathbf{v}}_{I_k} \Delta t - \frac{1}{2}{}^G\mathbf{g}\Delta t^2 + \frac{1}{2} \text{}^{I_k}_{G}\hat{\mathbf{R}}^\top(\mathbf{a}_{m,k} - \hat{\mathbf{b}}_{\mathbf{a},k})\Delta t^2 \end{align*}" src="form_351.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>Pointer to state </td></tr>
    <tr><td class="paramname">dt</td><td>Time we should integrate over </td></tr>
    <tr><td class="paramname">w_hat1</td><td>Angular velocity with bias removed </td></tr>
    <tr><td class="paramname">a_hat1</td><td>Linear acceleration with bias removed </td></tr>
    <tr><td class="paramname">w_hat2</td><td>Next angular velocity with bias removed </td></tr>
    <tr><td class="paramname">a_hat2</td><td>Next linear acceleration with bias removed </td></tr>
    <tr><td class="paramname">new_q</td><td>The resulting new orientation after integration </td></tr>
    <tr><td class="paramname">new_v</td><td>The resulting new velocity after integration </td></tr>
    <tr><td class="paramname">new_p</td><td>The resulting new position after integration </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abfc8dcea867622ef57e740e5ab884538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfc8dcea867622ef57e740e5ab884538">&#9670;&nbsp;</a></span>predict_mean_rk4()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Propagator::predict_mean_rk4 </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classov__msckf_1_1State.html">State</a> &gt;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>w_hat1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>a_hat1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>w_hat2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>a_hat2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector4d &amp;&#160;</td>
          <td class="paramname"><em>new_q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>new_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3d &amp;&#160;</td>
          <td class="paramname"><em>new_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>RK4 imu mean propagation. </p>
<p>See this wikipedia page on <a href="https://en.wikipedia.org/wiki/Runge%E2%80%93Kutta_methods">Runge-Kutta Methods</a>. We are doing a RK4 method, <a href="http://mathworld.wolfram.com/Runge-KuttaMethod.html">this wolframe page</a> has the forth order equation defined below. We define function <img class="formulaInl" alt="$ f(t,y) $" src="form_352.png"/> where y is a function of time t, see <a class="el" href="propagation.html#imu_kinematic">IMU Kinematics</a> for the definition of the continous-time functions.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} {k_1} &amp;= f({t_0}, y_0) \Delta t \\ {k_2} &amp;= f( {t_0}+{\Delta t \over 2}, y_0 + {1 \over 2}{k_1} ) \Delta t \\ {k_3} &amp;= f( {t_0}+{\Delta t \over 2}, y_0 + {1 \over 2}{k_2} ) \Delta t \\ {k_4} &amp;= f( {t_0} + {\Delta t}, y_0 + {k_3} ) \Delta t \\ y_{0+\Delta t} &amp;= y_0 + \left( {{1 \over 6}{k_1} + {1 \over 3}{k_2} + {1 \over 3}{k_3} + {1 \over 6}{k_4}} \right) \end{align*}" src="form_353.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>Pointer to state </td></tr>
    <tr><td class="paramname">dt</td><td>Time we should integrate over </td></tr>
    <tr><td class="paramname">w_hat1</td><td>Angular velocity with bias removed </td></tr>
    <tr><td class="paramname">a_hat1</td><td>Linear acceleration with bias removed </td></tr>
    <tr><td class="paramname">w_hat2</td><td>Next angular velocity with bias removed </td></tr>
    <tr><td class="paramname">a_hat2</td><td>Next linear acceleration with bias removed </td></tr>
    <tr><td class="paramname">new_q</td><td>The resulting new orientation after integration </td></tr>
    <tr><td class="paramname">new_v</td><td>The resulting new velocity after integration </td></tr>
    <tr><td class="paramname">new_p</td><td>The resulting new position after integration </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac96e7c40b696501a1f68097e10dde319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac96e7c40b696501a1f68097e10dde319">&#9670;&nbsp;</a></span>propagate_and_clone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Propagator::propagate_and_clone </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classov__msckf_1_1State.html">State</a> &gt;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timestamp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Propagate state up to given timestamp and then clone. </p>
<p>This will first collect all imu readings that occured between the <em>current</em> state time and the new time we want the state to be at. If we don't have any imu readings we will try to extrapolate into the future. After propagating the mean and covariance using our dynamics, We clone the current imu pose as a new clone in our state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>Pointer to state </td></tr>
    <tr><td class="paramname">timestamp</td><td>Time to propagate to and clone at (CAM clock frame) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2f2d18be72bfc40bab5ae5eab2bae10e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f2d18be72bfc40bab5ae5eab2bae10e">&#9670;&nbsp;</a></span>select_imu_readings()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structov__core_1_1ImuData.html">ov_core::ImuData</a> &gt; Propagator::select_imu_readings </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structov__core_1_1ImuData.html">ov_core::ImuData</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>imu_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>warn</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function that given current imu data, will select imu readings between the two times. </p>
<p>This will create measurements that we will integrate with, and an extra measurement at the end. We use the <a class="el" href="classov__msckf_1_1Propagator.html#a3dde6d888eec85594aa6a864d141d5dc">interpolate_data()</a> function to "cut" the imu readings at the begining and end of the integration. The timestamps passed should already take into account the time offset values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">imu_data</td><td>IMU data we will select measurements from </td></tr>
    <tr><td class="paramname">time0</td><td>Start timestamp </td></tr>
    <tr><td class="paramname">time1</td><td>End timestamp </td></tr>
    <tr><td class="paramname">warn</td><td>If we should warn if we don't have enough IMU to propagate with (e.g. fast prop will get warnings otherwise) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of measurements (if we could compute them) </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
