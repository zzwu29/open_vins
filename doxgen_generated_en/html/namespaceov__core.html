<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenVINS: ov_core Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpenVINS
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ov_core Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Core algorithms for OpenVINS.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classov__core_1_1BsplineSE3.html">BsplineSE3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">B-Spline which performs interpolation over SE(3) manifold.  <a href="classov__core_1_1BsplineSE3.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classov__core_1_1CamBase.html">CamBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base pinhole camera model class.  <a href="classov__core_1_1CamBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classov__core_1_1CamEqui.html">CamEqui</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fisheye / equadistant model pinhole camera model class.  <a href="classov__core_1_1CamEqui.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structov__core_1_1CameraData.html">CameraData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct for a collection of camera measurements.  <a href="structov__core_1_1CameraData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classov__core_1_1CamRadtan.html">CamRadtan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Radial-tangential / Brownâ€“Conrady model pinhole camera model class.  <a href="classov__core_1_1CamRadtan.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classov__core_1_1CpiBase.html">CpiBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for continuous preintegration integrators.  <a href="classov__core_1_1CpiBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classov__core_1_1CpiV1.html">CpiV1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Model 1 of continuous preintegration.  <a href="classov__core_1_1CpiV1.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classov__core_1_1CpiV2.html">CpiV2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Model 2 of continuous preintegration.  <a href="classov__core_1_1CpiV2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classov__core_1_1DatasetReader.html">DatasetReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper functions to read in dataset files.  <a href="classov__core_1_1DatasetReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classov__core_1_1Feature.html">Feature</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sparse feature class used to collect measurements.  <a href="classov__core_1_1Feature.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classov__core_1_1FeatureDatabase.html">FeatureDatabase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Database containing features we are currently tracking.  <a href="classov__core_1_1FeatureDatabase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classov__core_1_1FeatureHelper.html">FeatureHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains some nice helper functions for features.  <a href="classov__core_1_1FeatureHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classov__core_1_1FeatureInitializer.html">FeatureInitializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that triangulates feature.  <a href="classov__core_1_1FeatureInitializer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structov__core_1_1FeatureInitializerOptions.html">FeatureInitializerOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct which stores all our feature initializer options.  <a href="structov__core_1_1FeatureInitializerOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classov__core_1_1Grider__FAST.html">Grider_FAST</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts FAST features in a grid pattern.  <a href="classov__core_1_1Grider__FAST.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classov__core_1_1Grider__GRID.html">Grider_GRID</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts FAST features in a grid pattern.  <a href="classov__core_1_1Grider__GRID.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structov__core_1_1ImuData.html">ImuData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct for a single imu measurement (time, wm, am)  <a href="structov__core_1_1ImuData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classov__core_1_1LambdaBody.html">LambdaBody</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to do OpenCV parallelization.  <a href="classov__core_1_1LambdaBody.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classov__core_1_1Printer.html">Printer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classov__core_1_1Printer.html" title="Printer for open_vins that allows for various levels of printing to be done. ">Printer</a> for open_vins that allows for various levels of printing to be done.  <a href="classov__core_1_1Printer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classov__core_1_1TrackAruco.html">TrackAruco</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tracking of OpenCV Aruoc tags.  <a href="classov__core_1_1TrackAruco.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classov__core_1_1TrackBase.html">TrackBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visual feature tracking base class.  <a href="classov__core_1_1TrackBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classov__core_1_1TrackDescriptor.html">TrackDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Descriptor-based visual tracking.  <a href="classov__core_1_1TrackDescriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classov__core_1_1TrackKLT.html">TrackKLT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">KLT tracking of features.  <a href="classov__core_1_1TrackKLT.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classov__core_1_1TrackSIM.html">TrackSIM</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simulated tracker for when we already have uv measurements!  <a href="classov__core_1_1TrackSIM.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classov__core_1_1YamlParser.html">YamlParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to do OpenCV yaml parsing from both file and ROS.  <a href="classov__core_1_1YamlParser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1d2aafa6a756bb70fcd9f52695b4e573"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; double, 4, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceov__core.html#a1d2aafa6a756bb70fcd9f52695b4e573">rot_2_quat</a> (const Eigen::Matrix&lt; double, 3, 3 &gt; &amp;rot)</td></tr>
<tr class="memdesc:a1d2aafa6a756bb70fcd9f52695b4e573"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a JPL quaternion from a rotation matrix.  <a href="#a1d2aafa6a756bb70fcd9f52695b4e573">More...</a><br /></td></tr>
<tr class="separator:a1d2aafa6a756bb70fcd9f52695b4e573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24012c54df35621a935655b2e230169d"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; double, 3, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceov__core.html#a24012c54df35621a935655b2e230169d">skew_x</a> (const Eigen::Matrix&lt; double, 3, 1 &gt; &amp;w)</td></tr>
<tr class="memdesc:a24012c54df35621a935655b2e230169d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skew-symmetric matrix from a given 3x1 vector.  <a href="#a24012c54df35621a935655b2e230169d">More...</a><br /></td></tr>
<tr class="separator:a24012c54df35621a935655b2e230169d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb06397034cc6b346efb9517ed3757e"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; double, 3, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceov__core.html#adfb06397034cc6b346efb9517ed3757e">quat_2_Rot</a> (const Eigen::Matrix&lt; double, 4, 1 &gt; &amp;q)</td></tr>
<tr class="memdesc:adfb06397034cc6b346efb9517ed3757e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts JPL quaterion to SO(3) rotation matrix.  <a href="#adfb06397034cc6b346efb9517ed3757e">More...</a><br /></td></tr>
<tr class="separator:adfb06397034cc6b346efb9517ed3757e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa708e95617ccac1c880451014f2715fa"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; double, 4, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceov__core.html#aa708e95617ccac1c880451014f2715fa">quat_multiply</a> (const Eigen::Matrix&lt; double, 4, 1 &gt; &amp;q, const Eigen::Matrix&lt; double, 4, 1 &gt; &amp;p)</td></tr>
<tr class="memdesc:aa708e95617ccac1c880451014f2715fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two JPL quaternions.  <a href="#aa708e95617ccac1c880451014f2715fa">More...</a><br /></td></tr>
<tr class="separator:aa708e95617ccac1c880451014f2715fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf2593d3bde63e31ac9fc20e345271dc"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; double, 3, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceov__core.html#aaf2593d3bde63e31ac9fc20e345271dc">vee</a> (const Eigen::Matrix&lt; double, 3, 3 &gt; &amp;w_x)</td></tr>
<tr class="memdesc:aaf2593d3bde63e31ac9fc20e345271dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns vector portion of skew-symmetric.  <a href="#aaf2593d3bde63e31ac9fc20e345271dc">More...</a><br /></td></tr>
<tr class="separator:aaf2593d3bde63e31ac9fc20e345271dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a835a207e29f0e50ddbf66d8ddce47514"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; double, 3, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceov__core.html#a835a207e29f0e50ddbf66d8ddce47514">exp_so3</a> (const Eigen::Matrix&lt; double, 3, 1 &gt; &amp;w)</td></tr>
<tr class="memdesc:a835a207e29f0e50ddbf66d8ddce47514"><td class="mdescLeft">&#160;</td><td class="mdescRight">SO(3) matrix exponential.  <a href="#a835a207e29f0e50ddbf66d8ddce47514">More...</a><br /></td></tr>
<tr class="separator:a835a207e29f0e50ddbf66d8ddce47514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bbbcb3ed59aa7dff7883c2e8644d9fb"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; double, 3, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceov__core.html#a1bbbcb3ed59aa7dff7883c2e8644d9fb">log_so3</a> (const Eigen::Matrix&lt; double, 3, 3 &gt; &amp;R)</td></tr>
<tr class="memdesc:a1bbbcb3ed59aa7dff7883c2e8644d9fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">SO(3) matrix logarithm.  <a href="#a1bbbcb3ed59aa7dff7883c2e8644d9fb">More...</a><br /></td></tr>
<tr class="separator:a1bbbcb3ed59aa7dff7883c2e8644d9fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8907fdb4273f23741299fb23a1c1f572"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix4d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceov__core.html#a8907fdb4273f23741299fb23a1c1f572">exp_se3</a> (Eigen::Matrix&lt; double, 6, 1 &gt; vec)</td></tr>
<tr class="memdesc:a8907fdb4273f23741299fb23a1c1f572"><td class="mdescLeft">&#160;</td><td class="mdescRight">SE(3) matrix exponential function.  <a href="#a8907fdb4273f23741299fb23a1c1f572">More...</a><br /></td></tr>
<tr class="separator:a8907fdb4273f23741299fb23a1c1f572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf3626f4ed6392b8b0b0d0a75ff08a61"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; double, 6, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceov__core.html#aaf3626f4ed6392b8b0b0d0a75ff08a61">log_se3</a> (Eigen::Matrix4d mat)</td></tr>
<tr class="memdesc:aaf3626f4ed6392b8b0b0d0a75ff08a61"><td class="mdescLeft">&#160;</td><td class="mdescRight">SE(3) matrix logarithm.  <a href="#aaf3626f4ed6392b8b0b0d0a75ff08a61">More...</a><br /></td></tr>
<tr class="separator:aaf3626f4ed6392b8b0b0d0a75ff08a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2854f4368bab599be2404f396f5ee434"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix4d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceov__core.html#a2854f4368bab599be2404f396f5ee434">hat_se3</a> (const Eigen::Matrix&lt; double, 6, 1 &gt; &amp;vec)</td></tr>
<tr class="memdesc:a2854f4368bab599be2404f396f5ee434"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hat operator for R^6 -&gt; Lie Algebra se(3)  <a href="#a2854f4368bab599be2404f396f5ee434">More...</a><br /></td></tr>
<tr class="separator:a2854f4368bab599be2404f396f5ee434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba0a3888c4f1998478719dc70597ac73"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix4d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceov__core.html#aba0a3888c4f1998478719dc70597ac73">Inv_se3</a> (const Eigen::Matrix4d &amp;T)</td></tr>
<tr class="memdesc:aba0a3888c4f1998478719dc70597ac73"><td class="mdescLeft">&#160;</td><td class="mdescRight">SE(3) matrix analytical inverse.  <a href="#aba0a3888c4f1998478719dc70597ac73">More...</a><br /></td></tr>
<tr class="separator:aba0a3888c4f1998478719dc70597ac73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ebbc28aa8b0945da800771168f7c843"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; double, 4, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceov__core.html#a3ebbc28aa8b0945da800771168f7c843">Inv</a> (Eigen::Matrix&lt; double, 4, 1 &gt; q)</td></tr>
<tr class="memdesc:a3ebbc28aa8b0945da800771168f7c843"><td class="mdescLeft">&#160;</td><td class="mdescRight">JPL Quaternion inverse.  <a href="#a3ebbc28aa8b0945da800771168f7c843">More...</a><br /></td></tr>
<tr class="separator:a3ebbc28aa8b0945da800771168f7c843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03115c09fd2fa8a6af23830b9230a683"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; double, 4, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceov__core.html#a03115c09fd2fa8a6af23830b9230a683">Omega</a> (Eigen::Matrix&lt; double, 3, 1 &gt; w)</td></tr>
<tr class="memdesc:a03115c09fd2fa8a6af23830b9230a683"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrated quaternion from angular velocity.  <a href="#a03115c09fd2fa8a6af23830b9230a683">More...</a><br /></td></tr>
<tr class="separator:a03115c09fd2fa8a6af23830b9230a683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c4586cceb6f81771921e61e135dcaed"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; double, 4, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceov__core.html#a6c4586cceb6f81771921e61e135dcaed">quatnorm</a> (Eigen::Matrix&lt; double, 4, 1 &gt; q_t)</td></tr>
<tr class="memdesc:a6c4586cceb6f81771921e61e135dcaed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes a quaternion to make sure it is unit norm.  <a href="#a6c4586cceb6f81771921e61e135dcaed">More...</a><br /></td></tr>
<tr class="separator:a6c4586cceb6f81771921e61e135dcaed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a518b7324a4106ccad60558e2e5c4b14f"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; double, 3, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceov__core.html#a518b7324a4106ccad60558e2e5c4b14f">Jl_so3</a> (const Eigen::Matrix&lt; double, 3, 1 &gt; &amp;w)</td></tr>
<tr class="memdesc:a518b7324a4106ccad60558e2e5c4b14f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes left Jacobian of SO(3)  <a href="#a518b7324a4106ccad60558e2e5c4b14f">More...</a><br /></td></tr>
<tr class="separator:a518b7324a4106ccad60558e2e5c4b14f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0406d085d6175d3bc8a539328ec214b5"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; double, 3, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceov__core.html#a0406d085d6175d3bc8a539328ec214b5">Jr_so3</a> (const Eigen::Matrix&lt; double, 3, 1 &gt; &amp;w)</td></tr>
<tr class="memdesc:a0406d085d6175d3bc8a539328ec214b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes right Jacobian of SO(3)  <a href="#a0406d085d6175d3bc8a539328ec214b5">More...</a><br /></td></tr>
<tr class="separator:a0406d085d6175d3bc8a539328ec214b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af608ab8e3f8cd8554ade192cd804b7ce"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; double, 3, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceov__core.html#af608ab8e3f8cd8554ade192cd804b7ce">rot2rpy</a> (const Eigen::Matrix&lt; double, 3, 3 &gt; &amp;rot)</td></tr>
<tr class="memdesc:af608ab8e3f8cd8554ade192cd804b7ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets roll, pitch, yaw of argument rotation (in that order).  <a href="#af608ab8e3f8cd8554ade192cd804b7ce">More...</a><br /></td></tr>
<tr class="separator:af608ab8e3f8cd8554ade192cd804b7ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3268e0844642c119fe45c2880afb581"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; double, 3, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceov__core.html#ab3268e0844642c119fe45c2880afb581">rot_x</a> (double t)</td></tr>
<tr class="memdesc:ab3268e0844642c119fe45c2880afb581"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct rotation matrix from given roll.  <a href="#ab3268e0844642c119fe45c2880afb581">More...</a><br /></td></tr>
<tr class="separator:ab3268e0844642c119fe45c2880afb581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a212d931b6f4325052b3169ad6161a3"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; double, 3, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceov__core.html#a2a212d931b6f4325052b3169ad6161a3">rot_y</a> (double t)</td></tr>
<tr class="memdesc:a2a212d931b6f4325052b3169ad6161a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct rotation matrix from given pitch.  <a href="#a2a212d931b6f4325052b3169ad6161a3">More...</a><br /></td></tr>
<tr class="separator:a2a212d931b6f4325052b3169ad6161a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a512a53c9e1519a8e202277db433d37d1"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; double, 3, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceov__core.html#a512a53c9e1519a8e202277db433d37d1">rot_z</a> (double t)</td></tr>
<tr class="memdesc:a512a53c9e1519a8e202277db433d37d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct rotation matrix from given yaw.  <a href="#a512a53c9e1519a8e202277db433d37d1">More...</a><br /></td></tr>
<tr class="separator:a512a53c9e1519a8e202277db433d37d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Core algorithms for OpenVINS. </p>
<p>This has the core algorithms that all projects within the OpenVINS ecosystem leverage. The purpose is to allow for the reuse of code that could be shared between different localization systems (i.e. msckf-based, batch-based, etc.). These algorithms are the foundation which is necessary before we can even write an estimator that can perform localization. The key components of the <a class="el" href="namespaceov__core.html" title="Core algorithms for OpenVINS. ">ov_core</a> codebase are the following:</p>
<ul>
<li>3d feature initialization (see <a class="el" href="classov__core_1_1FeatureInitializer.html">ov_core::FeatureInitializer</a>)</li>
<li>SE(3) b-spline (see <a class="el" href="classov__core_1_1BsplineSE3.html">ov_core::BsplineSE3</a>)</li>
<li>KLT, descriptor, aruco, and simulation feature trackers</li>
<li>Groundtruth dataset reader (see <a class="el" href="classov__core_1_1DatasetReader.html">ov_core::DatasetReader</a>)</li>
<li>Quaternion and other manifold math operations</li>
<li>Generic type system and their implementations (see <a class="el" href="namespaceov__type.html">ov_type</a> namespace)</li>
<li>Closed-form preintegration <a class="el" href="citelist.html#CITEREF_Eckenhoff2019IJRR">[6]</a></li>
</ul>
<p>Please take a look at classes that we offer for the user to leverage as each has its own documentation. If you are looking for the estimator please take a look at the <a class="el" href="namespaceov__msckf.html" title="Extended Kalman Filter estimator. ">ov_msckf</a> project which leverages these algorithms. If you are looking for the different types please take a look at the <a class="el" href="namespaceov__type.html" title="Dynamic type system types. ">ov_type</a> namespace for the ones we have. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a8907fdb4273f23741299fb23a1c1f572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8907fdb4273f23741299fb23a1c1f572">&#9670;&nbsp;</a></span>exp_se3()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix4d ov_core::exp_se3 </td>
          <td>(</td>
          <td class="paramtype">Eigen::Matrix&lt; double, 6, 1 &gt;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SE(3) matrix exponential function. </p>
<p>Equation is from Ethan Eade's reference: <a href="http://ethaneade.com/lie.pdf">http://ethaneade.com/lie.pdf</a> </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \exp([\boldsymbol\omega,\mathbf u])&amp;=\begin{bmatrix} \mathbf R &amp; \mathbf V \mathbf u \\ \mathbf 0 &amp; 1 \end{bmatrix} \\[1em] \mathbf R &amp;= \mathbf I + A \lfloor \boldsymbol\omega \times\rfloor + B \lfloor \boldsymbol\omega \times\rfloor^2 \\ \mathbf V &amp;= \mathbf I + B \lfloor \boldsymbol\omega \times\rfloor + C \lfloor \boldsymbol\omega \times\rfloor^2 \end{align*}" src="form_329.png"/>
</p>
<p> where we have the following definitions </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \theta &amp;= \sqrt{\boldsymbol\omega^\top\boldsymbol\omega} \\ A &amp;= \sin\theta/\theta \\ B &amp;= (1-\cos\theta)/\theta^2 \\ C &amp;= (1-A)/\theta^2 \end{align*}" src="form_330.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>6x1 in the R(6) space [omega, u] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>4x4 SE(3) matrix </dd></dl>

</div>
</div>
<a id="a835a207e29f0e50ddbf66d8ddce47514"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a835a207e29f0e50ddbf66d8ddce47514">&#9670;&nbsp;</a></span>exp_so3()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;double, 3, 3&gt; ov_core::exp_so3 </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, 3, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>w</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SO(3) matrix exponential. </p>
<p>SO(3) matrix exponential mapping from the vector to SO(3) lie group. This formula ends up being the <a href="https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula">Rodrigues formula</a>. This definition was taken from "Lie Groups for 2D and 3D Transformations" by Ethan Eade equation 15. <a href="http://ethaneade.com/lie.pdf">http://ethaneade.com/lie.pdf</a></p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \exp\colon\mathfrak{so}(3)&amp;\to SO(3) \\ \exp(\mathbf{v}) &amp;= \mathbf{I} +\frac{\sin{\theta}}{\theta}\lfloor\mathbf{v}\times\rfloor +\frac{1-\cos{\theta}}{\theta^2}\lfloor\mathbf{v}\times\rfloor^2 \\ \mathrm{where}&amp;\quad \theta^2 = \mathbf{v}^\top\mathbf{v} \end{align*}" src="form_327.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">w</td><td>3x1 vector in R(3) we will take the exponential of </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SO(3) rotation matrix </dd></dl>

</div>
</div>
<a id="a2854f4368bab599be2404f396f5ee434"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2854f4368bab599be2404f396f5ee434">&#9670;&nbsp;</a></span>hat_se3()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix4d ov_core::hat_se3 </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, 6, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hat operator for R^6 -&gt; Lie Algebra se(3) </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \boldsymbol\Omega^{\wedge} = \begin{bmatrix} \lfloor \boldsymbol\omega \times\rfloor &amp; \mathbf u \\ \mathbf 0 &amp; 0 \end{bmatrix} \end{align*}" src="form_333.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>6x1 in the R(6) space [omega, u] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Lie algebra se(3) 4x4 matrix </dd></dl>

</div>
</div>
<a id="a3ebbc28aa8b0945da800771168f7c843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ebbc28aa8b0945da800771168f7c843">&#9670;&nbsp;</a></span>Inv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;double, 4, 1&gt; ov_core::Inv </td>
          <td>(</td>
          <td class="paramtype">Eigen::Matrix&lt; double, 4, 1 &gt;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>JPL Quaternion inverse. </p>
<p>See equation 21 in <a href="http://mars.cs.umn.edu/tr/reports/Trawny05b.pdf">Indirect Kalman Filter for 3D Attitude Estimation</a>. </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \bar{q}^{-1} = \begin{bmatrix} -\mathbf{q} \\ q_4 \end{bmatrix} \end{align*}" src="form_335.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>quaternion we want to change </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>inversed quaternion </dd></dl>

</div>
</div>
<a id="aba0a3888c4f1998478719dc70597ac73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba0a3888c4f1998478719dc70597ac73">&#9670;&nbsp;</a></span>Inv_se3()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix4d ov_core::Inv_se3 </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix4d &amp;&#160;</td>
          <td class="paramname"><em>T</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SE(3) matrix analytical inverse. </p>
<p>It seems that using the .inverse() function is not a good way. This should be used in all cases we need the inverse instead of numerical inverse. <a href="https://github.com/rpng/open_vins/issues/12">https://github.com/rpng/open_vins/issues/12</a> </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \mathbf{T}^{-1} = \begin{bmatrix} \mathbf{R}^\top &amp; -\mathbf{R}^\top\mathbf{p} \\ \mathbf{0} &amp; 1 \end{bmatrix} \end{align*}" src="form_334.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>SE(3) matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>inversed SE(3) matrix </dd></dl>

</div>
</div>
<a id="a518b7324a4106ccad60558e2e5c4b14f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a518b7324a4106ccad60558e2e5c4b14f">&#9670;&nbsp;</a></span>Jl_so3()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;double, 3, 3&gt; ov_core::Jl_so3 </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, 3, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>w</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes left Jacobian of SO(3) </p>
<p>The left Jacobian of SO(3) is defined equation (7.77b) in <a href="http://asrl.utias.utoronto.ca/~tdb/bib/barfoot_ser17.pdf">State Estimation for Robotics</a> by Timothy D. Barfoot. Specifically it is the following (with <img class="formulaInl" alt="$\theta=|\boldsymbol\theta|$" src="form_336.png"/> and <img class="formulaInl" alt="$\mathbf a=\boldsymbol\theta/|\boldsymbol\theta|$" src="form_337.png"/>): </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} J_l(\boldsymbol\theta) = \frac{\sin\theta}{\theta}\mathbf I + \Big(1-\frac{\sin\theta}{\theta}\Big)\mathbf a \mathbf a^\top + \frac{1-\cos\theta}{\theta}\lfloor \mathbf a \times\rfloor \end{align*}" src="form_338.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>axis-angle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The left Jacobian of SO(3) </dd></dl>

</div>
</div>
<a id="a0406d085d6175d3bc8a539328ec214b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0406d085d6175d3bc8a539328ec214b5">&#9670;&nbsp;</a></span>Jr_so3()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;double, 3, 3&gt; ov_core::Jr_so3 </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, 3, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>w</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes right Jacobian of SO(3) </p>
<p>The right Jacobian of SO(3) is related to the left by Jl(-w)=Jr(w). See equation (7.87) in <a href="http://asrl.utias.utoronto.ca/~tdb/bib/barfoot_ser17.pdf">State Estimation for Robotics</a> by Timothy D. Barfoot. See <a class="el" href="namespaceov__core.html#a518b7324a4106ccad60558e2e5c4b14f">Jl_so3()</a> for the definition of the left Jacobian of SO(3).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>axis-angle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The right Jacobian of SO(3) </dd></dl>

</div>
</div>
<a id="aaf3626f4ed6392b8b0b0d0a75ff08a61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf3626f4ed6392b8b0b0d0a75ff08a61">&#9670;&nbsp;</a></span>log_se3()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;double, 6, 1&gt; ov_core::log_se3 </td>
          <td>(</td>
          <td class="paramtype">Eigen::Matrix4d&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SE(3) matrix logarithm. </p>
<p>Equation is from Ethan Eade's reference: <a href="http://ethaneade.com/lie.pdf">http://ethaneade.com/lie.pdf</a> </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \boldsymbol\omega &amp;=\mathrm{skew\_offdiags}\Big(\frac{\theta}{2\sin\theta}(\mathbf R - \mathbf R^\top)\Big) \\ \mathbf u &amp;= \mathbf V^{-1}\mathbf t \end{align*}" src="form_331.png"/>
</p>
<p> where we have the following definitions </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \theta &amp;= \mathrm{arccos}((\mathrm{tr}(\mathbf R)-1)/2) \\ \mathbf V^{-1} &amp;= \mathbf I - \frac{1}{2} \lfloor \boldsymbol\omega \times\rfloor + \frac{1}{\theta^2}\Big(1-\frac{A}{2B}\Big)\lfloor \boldsymbol\omega \times\rfloor^2 \end{align*}" src="form_332.png"/>
</p>
<p>This function is based on the GTSAM one as the original implementation was a bit unstable. See the following:</p><ul>
<li><a href="https://github.com/borglab/gtsam/">https://github.com/borglab/gtsam/</a></li>
<li><a href="https://github.com/borglab/gtsam/issues/746">https://github.com/borglab/gtsam/issues/746</a></li>
<li><a href="https://github.com/borglab/gtsam/pull/780">https://github.com/borglab/gtsam/pull/780</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>4x4 SE(3) matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>6x1 in the R(6) space [omega, u] </dd></dl>

</div>
</div>
<a id="a1bbbcb3ed59aa7dff7883c2e8644d9fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bbbcb3ed59aa7dff7883c2e8644d9fb">&#9670;&nbsp;</a></span>log_so3()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;double, 3, 1&gt; ov_core::log_so3 </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, 3, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SO(3) matrix logarithm. </p>
<p>This definition was taken from "Lie Groups for 2D and 3D Transformations" by Ethan Eade equation 17 &amp; 18. <a href="http://ethaneade.com/lie.pdf">http://ethaneade.com/lie.pdf</a> </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \theta &amp;= \textrm{arccos}(0.5(\textrm{trace}(\mathbf{R})-1)) \\ \lfloor\mathbf{v}\times\rfloor &amp;= \frac{\theta}{2\sin{\theta}}(\mathbf{R}-\mathbf{R}^\top) \end{align*}" src="form_328.png"/>
</p>
<p>This function is based on the GTSAM one as the original implementation was a bit unstable. See the following:</p><ul>
<li><a href="https://github.com/borglab/gtsam/">https://github.com/borglab/gtsam/</a></li>
<li><a href="https://github.com/borglab/gtsam/issues/746">https://github.com/borglab/gtsam/issues/746</a></li>
<li><a href="https://github.com/borglab/gtsam/pull/780">https://github.com/borglab/gtsam/pull/780</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">R</td><td>3x3 SO(3) rotation matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>3x1 in the R(3) space [omegax, omegay, omegaz] </dd></dl>

</div>
</div>
<a id="a03115c09fd2fa8a6af23830b9230a683"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03115c09fd2fa8a6af23830b9230a683">&#9670;&nbsp;</a></span>Omega()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;double, 4, 4&gt; ov_core::Omega </td>
          <td>(</td>
          <td class="paramtype">Eigen::Matrix&lt; double, 3, 1 &gt;&#160;</td>
          <td class="paramname"><em>w</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Integrated quaternion from angular velocity. </p>
<p>See equation (48) of trawny tech report <a href="http://mars.cs.umn.edu/tr/reports/Trawny05b.pdf">Indirect Kalman Filter for 3D Attitude Estimation</a>. </p>

</div>
</div>
<a id="adfb06397034cc6b346efb9517ed3757e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfb06397034cc6b346efb9517ed3757e">&#9670;&nbsp;</a></span>quat_2_Rot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;double, 3, 3&gt; ov_core::quat_2_Rot </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, 4, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts JPL quaterion to SO(3) rotation matrix. </p>
<p>This is based on equation 62 in <a href="http://mars.cs.umn.edu/tr/reports/Trawny05b.pdf">Indirect Kalman Filter for 3D Attitude Estimation</a>: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \mathbf{R} = (2q_4^2-1)\mathbf{I}_3-2q_4\lfloor\mathbf{q}\times\rfloor+2\mathbf{q}\mathbf{q}^\top \end{align*}" src="form_325.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>JPL quaternion </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>3x3 SO(3) rotation matrix </dd></dl>

</div>
</div>
<a id="aa708e95617ccac1c880451014f2715fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa708e95617ccac1c880451014f2715fa">&#9670;&nbsp;</a></span>quat_multiply()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;double, 4, 1&gt; ov_core::quat_multiply </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, 4, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, 4, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply two JPL quaternions. </p>
<p>This is based on equation 9 in <a href="http://mars.cs.umn.edu/tr/reports/Trawny05b.pdf">Indirect Kalman Filter for 3D Attitude Estimation</a>. We also enforce that the quaternion is unique by having q_4 be greater than zero. </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \bar{q}\otimes\bar{p}= \mathcal{L}(\bar{q})\bar{p}= \begin{bmatrix} q_4\mathbf{I}_3+\lfloor\mathbf{q}\times\rfloor &amp; \mathbf{q} \\ -\mathbf{q}^\top &amp; q_4 \end{bmatrix} \begin{bmatrix} \mathbf{p} \\ p_4 \end{bmatrix} \end{align*}" src="form_326.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>First JPL quaternion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Second JPL quaternion </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>4x1 resulting q*p quaternion </dd></dl>

</div>
</div>
<a id="a6c4586cceb6f81771921e61e135dcaed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c4586cceb6f81771921e61e135dcaed">&#9670;&nbsp;</a></span>quatnorm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;double, 4, 1&gt; ov_core::quatnorm </td>
          <td>(</td>
          <td class="paramtype">Eigen::Matrix&lt; double, 4, 1 &gt;&#160;</td>
          <td class="paramname"><em>q_t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Normalizes a quaternion to make sure it is unit norm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q_t</td><td>Quaternion to normalized </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Normalized quaterion </dd></dl>

</div>
</div>
<a id="af608ab8e3f8cd8554ade192cd804b7ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af608ab8e3f8cd8554ade192cd804b7ce">&#9670;&nbsp;</a></span>rot2rpy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;double, 3, 1&gt; ov_core::rot2rpy </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, 3, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rot</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets roll, pitch, yaw of argument rotation (in that order). </p>
<p>To recover the matrix: R_input = R_z(yaw)*R_y(pitch)*R_x(roll) If you are interested in how to compute Jacobians checkout this report: <a href="http://mars.cs.umn.edu/tr/reports/Trawny05c.pdf">http://mars.cs.umn.edu/tr/reports/Trawny05c.pdf</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rot</td><td>Rotation matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>roll, pitch, yaw values (in that order) </dd></dl>

</div>
</div>
<a id="a1d2aafa6a756bb70fcd9f52695b4e573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d2aafa6a756bb70fcd9f52695b4e573">&#9670;&nbsp;</a></span>rot_2_quat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;double, 4, 1&gt; ov_core::rot_2_quat </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, 3, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rot</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a JPL quaternion from a rotation matrix. </p>
<p>This is based on the equation 74 in <a href="http://mars.cs.umn.edu/tr/reports/Trawny05b.pdf">Indirect Kalman Filter for 3D Attitude Estimation</a>. In the implementation, we have 4 statements so that we avoid a division by zero and instead always divide by the largest diagonal element. This all comes from the definition of a rotation matrix, using the diagonal elements and an off-diagonal. </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \mathbf{R}(\bar{q})= \begin{bmatrix} q_1^2-q_2^2-q_3^2+q_4^2 &amp; 2(q_1q_2+q_3q_4) &amp; 2(q_1q_3-q_2q_4) \\ 2(q_1q_2-q_3q_4) &amp; -q_2^2+q_2^2-q_3^2+q_4^2 &amp; 2(q_2q_3+q_1q_4) \\ 2(q_1q_3+q_2q_4) &amp; 2(q_2q_3-q_1q_4) &amp; -q_1^2-q_2^2+q_3^2+q_4^2 \end{bmatrix} \end{align*}" src="form_323.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rot</td><td>3x3 rotation matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>4x1 quaternion </dd></dl>

</div>
</div>
<a id="ab3268e0844642c119fe45c2880afb581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3268e0844642c119fe45c2880afb581">&#9670;&nbsp;</a></span>rot_x()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;double, 3, 3&gt; ov_core::rot_x </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct rotation matrix from given roll. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>roll angle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2a212d931b6f4325052b3169ad6161a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a212d931b6f4325052b3169ad6161a3">&#9670;&nbsp;</a></span>rot_y()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;double, 3, 3&gt; ov_core::rot_y </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct rotation matrix from given pitch. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>pitch angle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a512a53c9e1519a8e202277db433d37d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a512a53c9e1519a8e202277db433d37d1">&#9670;&nbsp;</a></span>rot_z()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;double, 3, 3&gt; ov_core::rot_z </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct rotation matrix from given yaw. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>yaw angle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a24012c54df35621a935655b2e230169d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24012c54df35621a935655b2e230169d">&#9670;&nbsp;</a></span>skew_x()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;double, 3, 3&gt; ov_core::skew_x </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, 3, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>w</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Skew-symmetric matrix from a given 3x1 vector. </p>
<p>This is based on equation 6 in <a href="http://mars.cs.umn.edu/tr/reports/Trawny05b.pdf">Indirect Kalman Filter for 3D Attitude Estimation</a>: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \lfloor\mathbf{v}\times\rfloor = \begin{bmatrix} 0 &amp; -v_3 &amp; v_2 \\ v_3 &amp; 0 &amp; -v_1 \\ -v_2 &amp; v_1 &amp; 0 \end{bmatrix} \end{align*}" src="form_324.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">w</td><td>3x1 vector to be made a skew-symmetric </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>3x3 skew-symmetric matrix </dd></dl>

</div>
</div>
<a id="aaf2593d3bde63e31ac9fc20e345271dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf2593d3bde63e31ac9fc20e345271dc">&#9670;&nbsp;</a></span>vee()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;double, 3, 1&gt; ov_core::vee </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, 3, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>w_x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns vector portion of skew-symmetric. </p>
<p>See <a class="el" href="namespaceov__core.html#a24012c54df35621a935655b2e230169d" title="Skew-symmetric matrix from a given 3x1 vector. ">skew_x()</a> for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">w_x</td><td>skew-symmetric matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>3x1 vector portion of skew </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
